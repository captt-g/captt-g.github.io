{"meta":{"title":"Captt-g","subtitle":"","description":"","author":"Captt-g","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-24T13:47:14.027Z","updated":"2021-10-24T13:47:14.027Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"ME!","date":"2021-10-25T05:42:56.011Z","updated":"2021-10-25T05:42:56.011Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个普通大学生，喜欢打羽毛球。","author":"Captt-g"},{"title":"所有标签","date":"2021-10-25T05:19:37.526Z","updated":"2021-10-25T05:19:37.526Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-25T05:21:19.616Z","updated":"2021-10-25T05:21:19.616Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-10-25T06:48:15.750Z","updated":"2021-10-25T06:48:15.750Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"Captt-g"},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"html基础","slug":"计算机世界/html","date":"2021-11-02T14:20:52.299Z","updated":"2021-11-03T11:52:42.733Z","comments":true,"path":"2021/11/02/计算机世界/html/","link":"","permalink":"http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/html/","excerpt":"","text":"重要标签base标签： 1&lt;base href=&quot;/&quot;&gt; 用于指定基础的路径，指定以后，所有a连接都是以这个路径为基准。 文本级标签：p,span,a,b,i,u,em.文本级标签里只能放文字，图片，表单元素。 容器级标签：div,h系列,li,dt,dd.容器级标签中可以放任何东西。 水平线标签 &lt;hr/&gt;属性： align: 设定放置位置，left，right，center。 size：设定线条粗细，以像素为单位。 width：设定线条长度 color：设定线条颜色 noshade：不要阴影 &lt;div&gt;和&lt;span&gt;标签div标签：可以把标签中的内容分割为独立的区块，必须单独占据一行。 span标签：}与div作用一直，但不换行 字体标签特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp &lt; 小于号 &amp;lt &gt; 大于号 &amp;gt &amp; 和号 &amp;amp ￥ 人民币 &amp;yen © 版权 &amp;copy ® 注册商标 &amp;reg ° 摄氏度 &amp;deg ± 正负号 &amp;plusmn × 乘号 &amp;times ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 上标sup下标subp代表top，b代表bottom 120&lt;sup&gt;2&lt;/sup&gt;5&lt;sub&gt;3&lt;/sub&gt; 超链接a是anchor“锚”的意思。 链接到外部文件1&lt;a href=&quot;xxx.html&quot;&gt;进入外部链接&lt;/a&gt; 锚链接定位到页面的锚位置。 1&lt;a href=&quot;a.html#name1&quot;&gt;去往name为name1所在位置&lt;/a&gt; 邮件链接1&lt;a href=&quot;mailto:xxx@126.com&quot;&gt;点击进入邮箱&lt;/a&gt; 超链接的属性 href：目标url title：悬停文本 name：设置一个锚点名称 target：设置用什么方式打开页面，_self,_blank,_parent,_top. 图片标签样例： 1&lt;img src=&quot;url&quot;/&gt; 属性 src：源文件 width：宽度 height：高度，只指定一个值，图片会自动进行缩放。 alt：当图片无法显示的时候，用alt中的内容替代 title：悬停提示 align：设置相对位置，bottom，center，top，left，right 列表标签无序列表ul:unordered listli:list item 1234&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 有序列表ol:ordered list 1234&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ol&gt; 定义列表 dl:definition list dt:deifinition title dd:definition description123456&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;what&#x27;s up?&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;help me&lt;/dd&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}],"author":"Captt-g"},{"title":"用c++完成mac封装实验","slug":"计算机世界/mac封装","date":"2021-11-01T13:28:55.175Z","updated":"2021-11-01T14:01:46.709Z","comments":true,"path":"2021/11/01/计算机世界/mac封装/","link":"","permalink":"http://example.com/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/","excerpt":"","text":"MAC帧封装在终端输入数据，输出MAC帧包装后的相关信息。仅考虑单帧 MAC帧基本格式 前导码 帧定界符 目的地址 源地址 长度字段 数据字段 校验字段 7B 1B (6B) (6B) (2B) 46~1500字节 (4B) 题目条件目的地址：8000FF602CDC源地址：8000FE853A5F生成多项式： $$G(x)=x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$$ 程序思路 先通过已给条件填充数据的目的地址，原地址，数据字段，长度字段。 根据crc-32校验不包括前导码和定界符，通过已有数据计算出冗余码添加到mac末尾。 数据全部用string存储方便最后输出。 自己写hextobinary和binarytohex函数做数据转换。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Frame&#123;private: string Destination = &quot;8000FF602cdc&quot;; string Source = &quot;8000FE853a5f&quot;; string Divisor = &quot;100000100110000010001110110110111&quot;; string destinationBin = &quot;&quot;; string SourceBin = &quot;&quot;; string lengthField = &quot;&quot;; string data = &quot;&quot;; string dataBin = &quot;&quot;; string fcs = &quot;&quot;; string mac = &quot;&quot;; string macHex = &quot;&quot;; string fcsHex = &quot;&quot;; int macByteLenth = 18; string FOUR_BIT_BIN[16] = &#123; &quot;0000&quot;, &quot;0001&quot;, &quot;0010&quot;, &quot;0011&quot;, &quot;0100&quot;, &quot;0101&quot;, &quot;0110&quot;, &quot;0111&quot;, &quot;1000&quot;, &quot;1001&quot;, &quot;1010&quot;, &quot;1011&quot;, &quot;1100&quot;, &quot;1101&quot;, &quot;1110&quot;, &quot;1111&quot;&#125;; void input(); void dealWithDestinationAddress(); void dealWithSourceAddress(); void dealWithData(); void dealWithLengthField(); void dealWithFcs(); void dealWithMac(); string solveFcs(string dividend, string divisor); string dataToBinaryString(string data); string fillZero(string data, int finalBitLength, bool way); string hexToBinary(string hex); string binaryToHex(string binary); string toBinaryString(int num);public: void output(); void begin();&#125;;void Frame::begin()&#123; this-&gt;input(); this-&gt;dealWithDestinationAddress(); this-&gt;dealWithSourceAddress(); this-&gt;dealWithData(); this-&gt;dealWithLengthField(); this-&gt;mac += this-&gt;lengthField; this-&gt;mac += this-&gt;dataBin; this-&gt;dealWithFcs(); this-&gt;dealWithMac();&#125;void Frame::input()&#123; getline(cin, this-&gt;data); cout &lt;&lt; &quot;-----------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::output()&#123; cout &lt;&lt; &quot;MAC帧（二进制）为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;mac &lt;&lt; endl; cout &lt;&lt; &quot;目的地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Destination &lt;&lt; endl; cout &lt;&lt; &quot;原地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Source &lt;&lt; endl; cout &lt;&lt; &quot;长度为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macByteLenth &lt;&lt; endl; cout &lt;&lt; &quot;数据为:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;dataBin &lt;&lt; endl; cout &lt;&lt; &quot;FCS为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcs &lt;&lt; endl; cout &lt;&lt; &quot;MAC帧（十六进制）:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macHex &lt;&lt; endl; cout &lt;&lt; &quot;FCS(16进制):&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcsHex &lt;&lt; endl; cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::dealWithDestinationAddress()&#123; this-&gt;destinationBin = this-&gt;hexToBinary(this-&gt;Destination); this-&gt;mac += this-&gt;destinationBin;&#125;void Frame::dealWithSourceAddress()&#123; this-&gt;SourceBin = this-&gt;hexToBinary(this-&gt;Source); this-&gt;mac += this-&gt;SourceBin;&#125;void Frame::dealWithData()&#123; int dataByteLength = 0; this-&gt;dataBin = this-&gt;dataToBinaryString(data); dataByteLength = this-&gt;dataBin.size() / 8; if (dataByteLength &lt; 46) &#123; this-&gt;dataBin = this-&gt;fillZero(this-&gt;dataBin, 46 * 8, false); dataByteLength = 46; &#125; else if (dataByteLength &gt; 1500) &#123; cout &lt;&lt; &quot;输入超出范围&quot; &lt;&lt; endl; exit(0); &#125; this-&gt;macByteLenth += dataByteLength;&#125;void Frame::dealWithLengthField()&#123; this-&gt;lengthField = toBinaryString(this-&gt;macByteLenth); this-&gt;lengthField = this-&gt;fillZero(this-&gt;lengthField, 16, true);&#125;string Frame::toBinaryString(int num)&#123; string result = &quot;&quot;; while (num / 2 != 0) &#123; result.insert(0, to_string(num % 2)); num /= 2; &#125; result.insert(0, to_string(num)); return result;&#125;void Frame::dealWithFcs()&#123; string dividend = this-&gt;fillZero(this-&gt;mac, this-&gt;mac.length() + 32, false); this-&gt;fcs = this-&gt;solveFcs(dividend, this-&gt;Divisor); this-&gt;fcsHex = this-&gt;binaryToHex(this-&gt;fcs); this-&gt;mac += this-&gt;fcs;&#125;void Frame::dealWithMac()&#123; this-&gt;macHex = this-&gt;binaryToHex(this-&gt;mac);&#125;string Frame::solveFcs(string dividend, string divisor)&#123; string fcs = &quot;&quot;; int head = 0; int tail = head + divisor.length() - 1; int i; while (tail &lt; dividend.length()) &#123; if (&#x27;1&#x27; == dividend[head]) &#123; for (i = head; i &lt;= tail; i++) &#123; if (dividend[i] == divisor[i - head]) &#123; dividend[i] = &#x27;0&#x27;; &#125; else &#123; dividend[i] = &#x27;1&#x27;; &#125; &#125; &#125; head++; tail++; &#125; for (i = head; i &lt; dividend.length(); i++) &#123; fcs += dividend[i]; &#125; return fcs;&#125;string Frame::dataToBinaryString(string data)&#123; string result; string oneBit; for (int i = 0; i &lt; data.length(); i++) &#123; oneBit = toBinaryString(data[i]); oneBit = this-&gt;fillZero(oneBit, 8, true); result += oneBit; &#125; return result;&#125;string Frame::fillZero(string data, int finalBitLength, bool way)&#123; string result = &quot;&quot;; for (int i = data.length(); i &lt; finalBitLength; i++) &#123; result += &#x27;0&#x27;; &#125; if (way == true) &#123; result += data; &#125; else &#123; result = data + result; &#125; return result;&#125;string Frame::hexToBinary(string hex)&#123; string Binary = &quot;&quot;; int hexBitLength = hex.length(); for (int i = 0; i &lt; hexBitLength; i++) &#123; if (hex[i] &gt;= &#x27;0&#x27; &amp;&amp; hex[i] &lt;= &#x27;9&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;0&#x27;]; &#125; else if (hex[i] &gt;= &#x27;a&#x27; &amp;&amp; hex[i] &lt;= &#x27;z&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;a&#x27; + 10]; &#125; else &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;A&#x27; + 10]; &#125; &#125; return Binary;&#125;string Frame::binaryToHex(string binary)&#123; string binToHex = &quot;&quot;; string tmp = &quot;&quot;; for (size_t j = 0; j &lt; binary.size(); j += 4) &#123; tmp = binary.substr(j, 4); if (!tmp.compare(&quot;0000&quot;)) binToHex += &quot;0&quot;; else if (!tmp.compare(&quot;0001&quot;)) binToHex += &quot;1&quot;; else if (!tmp.compare(&quot;0010&quot;)) binToHex += &quot;2&quot;; else if (!tmp.compare(&quot;0011&quot;)) binToHex += &quot;3&quot;; else if (!tmp.compare(&quot;0100&quot;)) binToHex += &quot;4&quot;; else if (!tmp.compare(&quot;0101&quot;)) binToHex += &quot;5&quot;; else if (!tmp.compare(&quot;0110&quot;)) binToHex += &quot;6&quot;; else if (!tmp.compare(&quot;0111&quot;)) binToHex += &quot;7&quot;; else if (!tmp.compare(&quot;1000&quot;)) binToHex += &quot;8&quot;; else if (!tmp.compare(&quot;1001&quot;)) binToHex += &quot;9&quot;; else if (!tmp.compare(&quot;1010&quot;)) binToHex += &quot;A&quot;; else if (!tmp.compare(&quot;1011&quot;)) binToHex += &quot;B&quot;; else if (!tmp.compare(&quot;1100&quot;)) binToHex += &quot;C&quot;; else if (!tmp.compare(&quot;1101&quot;)) binToHex += &quot;D&quot;; else if (!tmp.compare(&quot;1110&quot;)) binToHex += &quot;E&quot;; else if (!tmp.compare(&quot;1111&quot;)) binToHex += &quot;F&quot;; else continue; &#125; return binToHex;&#125;//稍显丑陋。。。int main()&#123; Frame frame; frame.begin(); frame.output();&#125; 实现截图","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"香农公式术语","slug":"计算机世界/香农公式术语","date":"2021-10-27T08:56:00.203Z","updated":"2021-10-27T09:01:09.919Z","comments":true,"path":"2021/10/27/计算机世界/香农公式术语/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/","excerpt":"","text":"波特率波特率（也称信息传送速率、码元速率、符号速率、传码率），其定义为每秒钟传送码元的数目，码元速率的单位为“波特”，常用符号“Baud”表示，简写为“B”。 一个数字脉冲就是一个码元，我们用码元速率表示单位时间内信号波形的变换次数，即单位时间内通过信道传输的码元个数。若信号码元宽度为T秒，则码元速率B为：$$B = 1/T(Baud)$$ 比特率比特率也称数据传输速率，它的定义是单位时间内可以传输的比特数，单位为bps。比特率的计算公式为：$$\\mbox{比特率}=\\mbox{波特率}*\\mbox{每码元含有的bit数}$$ 怎么理解比特率和波特率之间的关系呢？我们可以假设一个信号只有两个电平状态，那么这个时候可以把低电平理解为“0”，高电平理解为“1”，这样每秒钟电平变化的次数也就是传输的0，1个数了，即比特率 = 波特率。但是有些信号可能不止两个电平，比如一个四电平的信号状态，那么每个电平就可以被理解成“00”，“01”，“10”，“11”，这样每次电平变化就能传输两位的数据了，即比特率 = 2 × 波特率。 带宽和容量带宽：一般信道都有一个最高的信号频率（频率是指每秒钟的周期数，而每个周期都会有几次电平变化）和最低的信号频率，只有在这两个频率之间的信号才能通过这个信道，这两个频率的差值就叫做这个信道的带宽，单位是Hz。 信道的容量：数据在信道中传输会有他们的速度——比特率，这里面最高的比特率就叫做这个信道的容量，单位是bps。 口语中也会把信道容量叫做“带宽”的，比如“带宽10M的网络”，“网络带宽是10M”等等。所以这两个概念也很容易混淆：我们平常所说的“带宽”不是带宽，而是信道容量，这一点心里要清楚.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"计算机网络","slug":"计算机世界/WireLine","date":"2021-10-27T01:38:37.020Z","updated":"2021-11-02T09:51:29.730Z","comments":true,"path":"2021/10/27/计算机世界/WireLine/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/WireLine/","excerpt":"","text":"物理层物理层基本概念物理层：解决怎样在连接各种计算机的传输媒体上传输数据比特流，而不指定具体的媒体。 物理层的任务：机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列固定和锁定装置等。电器特性：指明接口电缆中各条线上出现的电压范围。功能特性：指明某条线上出现某一电平的电压的意义。过程特性：指明对于不同功能的各种可能事件出现的顺序。转换任务：将并行数据转换为串行数据。 数据通信的基本知识数据通信系统： 源系统：分为源点，发送器（调制器） 传输系统：传输网络 目的系统：接收器（解调器），终点 常用术语：消息：例如语音，文字，图片等。数据：运送消息的载体。信号：数据的电气或电磁表现。模拟信号：连续的信号。数字信号：离散的信号。码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 关于信道的基本概念：定义：用来表示向某一个方向传送信息的媒体。交互方式：单工，半双工，全双工。基带信号：来自信源的信号称为基带信号，一般包含较多的低频成分，甚至有直流成分，许多信道不能传输这种低频分量和直流分量，所以必须对基带信号进行调制。 调制： 基带调制（编码）：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号。 带通调制：通过使用载波进行调制，将基带信号搬移到较高频段，并转换为模拟信号。转换完后的信号称为带通信号。 常用的编码方式： 不归零制：正电平代表1，负电平代表0.（没有自同步能力，不能从信号波形本身提取出信号的时钟频率）。 归零制：正脉冲代表1，负脉冲代表0。 曼彻斯特编码：为中心周期向下跳变代表1，向下跳变代表0。（也可以反过来） 差分曼彻斯特编码：在每一位中心始终都有跳变，位开始边界有跳变代表0，没有跳变代表1。 基本的带通调制方法： 调幅（AM）：即载波的振幅随基带数字信号变化。 调频（FM）：即载波的频率随基带的数字信号变化。 调相（PM）：即载波的初始相位随基带的数字型号变化。 为提高信息的传输速率，通常使用正交振幅调制（一个码元代表多个bit）。 信道的极限容量传输质量：码元的传输速率越高，或传输的距离越远，或噪声干扰越大，则传输媒体质量越大，失真越严重。 码间干扰：在接受端收到的信号波形失去了码元之间清晰的界限。 奈氏准则在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间干扰，使接受端识别数据称为不可能。 信噪比定义：信号的平均功率和噪声的平均功率之比，常记为$ S/N $,并用分贝（dB）作为度量单位。即：$$\\mbox{信噪比}(dB) = 10 \\log_{10}(S/N)(dB)$$ 香农公式$$C = W \\log_2(1+S/N)(bit/s)$$其中 W 为信道带宽，单位为（Hz），C为信道的极限传输速率，香农公式表明，信道的带宽或者信道的信噪比越大，信息的极限传输速率就越高。 术语https://please.sendmeto.icu/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/ 信道复用技术频分复用：相同时间不同频率时分复用：不同时间相同频率，将一个复用帧分为多个时隙，每个时隙分配给一个用户统计时分复用：动态分配的时分复用波分复用：光的频分复用，每隔120km添加一个放大器，可保证光信号不会衰减到不能被识别码分复用：各用户使用经过特殊挑选的不同码型，进行通信。 码分多址特点：很强的抗干扰能力，频谱类似于白噪声，不易被敌人发现。现在多使用在无线网中。复用方式：每一个比特时间再划分为m个短的间隔，称为码片，通常m的值为64或者128，使用CDMA的每个站被指派一个唯一的m bit的码片序列，一个站如果要发送1，则发送它自身的码片序列，如果要发送0，则发送自身码片序列的反码。惯例将码片中的0写作-1，将1写作+1.不同的码片序列必须相互正交。因为不同的码片序列之间是相互正交的，设S站的码片序列为S，T站的码片序列为T。$$S * T = 1/m \\Sigma S_i T_i = 0$$$$S * S = 1/m \\Sigma S_i^2 = 1$$因此如果S发射1，则接受方用$S * S$ 会得到1，如果S发射0，则接受方用$S * S$会得到-1.用此方法，如果接受方有S的码片序列，那么就可以收到A发射的消息。 数据链路层主要内容： 点对点信道和广播信道的特点，以及这两种信道所使用的协议的特点(PPP 协议一节 CSMA/CD 协议)。 数据链路层的三个基本问题：封装成帧，透明传输和差错检验。 以太网MAC层的硬件地址 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。 使用点对点信道的数据链路层数据链路和链路的区别： 链路：是从一个结点到相邻结点的一段物理线路（有线或者无线），而中间没有任何其他的交换结点。 数据链路：把视线协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层的协议数据单元：帧网络层的协议数据单元：IP数据报 点对点信道的数据链路层在进行通行的时候主要步骤： 结点A的数据链路层把网络层传下来的数据封装成帧 结点A把帧传输给结点B的数据链路层 结点B检验帧无差错，接受帧，否则丢弃帧 封装成帧在一段数据的前后分别添加首部和尾部，构成一个帧。首部SOH(Start Of Header),尾部EOT(End Of Transmission)是两种控制字符，并不是三个字符，在键盘中都不可输入。用于帧定界。 透明传输保证数据的完整性不因为数据中含有和定界符而在传输中丢失。 具体做法：发送端的数据链路层在数据中出现控制字符”SOH”,”EOT”,”ESC”的前面添加一个转移字符”ESC”，而在接受端的数据链路层删除这个转义字符，这种方法称为字符填充或者字节填充（byte stuffing）。 差错检验误码率：传输错误bit数占传输bit总数的比率CRC(Cyclic Redundancy Check)循环冗余检验技术被广泛用于数据链路层差错检验。检验方法： $$( M * 2^n ) / P= Q……R$$ 发送$M * 2^n + R$,接收方把每一帧都除以P，若余数为零则代表没有出现差错，否则代表出现差错，该式子中所有的除法均代表模二除法。其中P是n+1位二进制数，R是n位二进制数，被称作FCS(Frame Check Sequence)(冗余码，帧检验序列)。 CRC只能检测出bit差错，所以并不能进行可靠传输，如果想进行可靠传输，还需要增加帧编号，确认和重传机制，防止帧丢失，帧重复，帧失序。 详见https://please.sendmeto.icu/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/ 拓展以太网在数据链路层拓展以太网早期使用网桥，现在使用以太网交换机。==网桥==：根据mac帧的目的地址和地址表（交换表）对收到的帧进行转发和过滤。 ==以太网交换机==：实质是多接口网桥，内部地址表是通过自学习算法逐渐建立起来的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"LeetCode刷题记录","slug":"计算机世界/LeetCode","date":"2021-10-26T07:02:03.751Z","updated":"2021-10-26T13:08:54.228Z","comments":true,"path":"2021/10/26/计算机世界/LeetCode/","link":"","permalink":"http://example.com/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/LeetCode/","excerpt":"","text":"287. Find the Duplicate Number题目大意：给n+1个int值,1 &lt;= value &lt;= n,找出它们中的重复数字,时间复杂度为O(n^2),空间复杂度为O(1). 解决方法：使用二分法,记数组最大值，中值，最小值分别为max，mid，low，如果小于mid的数超过mid个，则重复的数字小于mid，否则大于mid。重复此过程。 123456789101112131415161718192021222324252627int findDuplicate(int *nums, int numsSize)&#123; int low = 0; int high = numsSize - 1; while (low &lt; high) &#123; int mid = (low + high) / 2; int count = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &lt;= mid) &#123; count++; &#125; &#125; if (count &gt; mid) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; return low;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"经典诗词","slug":"诗词世界/诗词世界","date":"2021-10-26T06:20:06.541Z","updated":"2021-11-02T15:09:29.599Z","comments":true,"path":"2021/10/26/诗词世界/诗词世界/","link":"","permalink":"http://example.com/2021/10/26/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/","excerpt":"","text":"临安春雨初霁（陆游)世味年来薄似纱，谁令骑马客京华。 小楼一夜听春雨，深巷明朝卖杏花。 矮纸斜行闲作草，晴窗细乳戏分茶。 素衣莫起风尘叹，犹及清明可到家。 临江仙·滚滚长江东逝水（杨慎）滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。","categories":[],"tags":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"}],"author":"Captt-g"},{"title":"JavaScript 基础语法学习笔记","slug":"计算机世界/JavaScript基础知识","date":"2021-10-25T13:15:22.546Z","updated":"2021-11-02T14:21:54.273Z","comments":true,"path":"2021/10/25/计算机世界/JavaScript基础知识/","link":"","permalink":"http://example.com/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"严格模式1&#x27;use strict&#x27;; 用break/continue和标签跳出多重循环只有在循环内部使用才可以调到标签所在位置。 123456outer: for(...)&#123; for(...)&#123; if(...) break outer;//从这里直接运行到alert &#125;&#125;alert(&#x27;Done!&#x27;) 函数箭头函数 12let func = ( arg1, arg2, ...argN)=&gt; expressionlet func = ( arg1, arg2, ...argN)=&gt; &#123; body &#125; 使用参数对expression求值并返回结果。等同于 123let func = function( arg1, arg2,... argN)&#123; return expression;&#125;; 例子 1let sum = ( a, b) =&gt; a + b; 对象js中的对象是一组键值对数据。 12345678910//创建空的对象let user=new Object();let user=&#123; name:&quot;John&quot;, age:30, &quot;like birds&quot;:true,&#125;;//删除属性delete user.age;alert(user[&quot;like birds&quot;]); 属性的命名没有限制，可以是任何字符串或者symbol，若命名数字也会被转换为字符串。 当被访问的属性不存在的时候会返回undefined。 计算属性当创建一个对象的时候，可以在对象字面量中使用方括号。 12345678910let fruit = prompt(&quot;Which fruit to buy?&quot;,&quot;apple&quot;);let bag=&#123; [fruit]:5,&#125;;alert(bag[fruit])//在方括号中使用更复杂的表达式let bag = &#123; [fruit+&#x27;Computers&#x27;]:5 ,&#125; 对象的克隆和引用对象名是对对象的引用，指向的是地址想要复制对象，可以使用 1Object.assign(dest, [src1, src2, src3...]) 该式子会把源对象的属性全部复制进dest 箭头函数没有自己的this箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。 123456789let user = &#123; firstName: &quot;Ilya&quot;, sayHi() &#123; let arrow = () =&gt; alert(this.firstName); arrow(); &#125;&#125;;user.sayHi(); // Ilya 这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用。 构造函数构造函数的两个约定： 命名以大写字母开头。 只能由new操作符来执行12345678function User(name)&#123; this.name=name; this.isAdmin=false;&#125;let user = new User(&quot;Jack&quot;);alert(user.name);alert(user.isAdmin); 从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"Captt-g"},{"title":"排序算法","slug":"计算机世界/Sort","date":"2021-10-24T13:10:15.993Z","updated":"2021-10-26T07:02:47.368Z","comments":true,"path":"2021/10/24/计算机世界/Sort/","link":"","permalink":"http://example.com/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/Sort/","excerpt":"","text":"插入排序 概念：0~p-1位置的数是排好序的，将第p位置上的数插入进排好序的数列里，形成新的排好序的数列。 12345678910void InsertSort(ElementType a[],int n)&#123; for(int i=1;i&lt;n;i++)&#123; ElementType tmp=a[i]; int j; for(j=i;j&gt;0&amp;&amp;a[j-1]&gt;tmp;j--)&#123; a[j]=a[j-1]; &#125; a[j]=tmp; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"当一个人","slug":"杂项/beaman","date":"2021-10-22T08:41:13.470Z","updated":"2021-10-24T15:05:35.571Z","comments":true,"path":"2021/10/22/杂项/beaman/","link":"","permalink":"http://example.com/2021/10/22/%E6%9D%82%E9%A1%B9/beaman/","excerpt":"","text":"当一个人 从明天开始我要当一个不再摆烂的人，早睡早起，每天吃早饭，认真看书学习，只在周末打游戏。","categories":[],"tags":[],"author":"Captt-g"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]}