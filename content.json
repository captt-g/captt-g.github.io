{"meta":{"title":"Captt-g","subtitle":"","description":"","author":"Captt-g","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-24T13:47:14.027Z","updated":"2021-10-24T13:47:14.027Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"ME!","date":"2021-10-25T05:42:56.011Z","updated":"2021-10-25T05:42:56.011Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个普通大学生，喜欢打羽毛球。","author":"Captt-g"},{"title":"所有标签","date":"2021-10-25T05:19:37.526Z","updated":"2021-10-25T05:19:37.526Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-25T05:21:19.616Z","updated":"2021-10-25T05:21:19.616Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-10-25T06:48:15.750Z","updated":"2021-10-25T06:48:15.750Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"Captt-g"},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA","slug":"计算机世界/JAVA","date":"2021-11-05T00:39:08.520Z","updated":"2021-11-05T00:39:56.703Z","comments":true,"path":"2021/11/05/计算机世界/JAVA/","link":"","permalink":"http://example.com/2021/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/JAVA/","excerpt":"","text":"基础概念与常识 Java 语言有哪些特点? JVM vs JDK vs JRE JVM JDK 和 JRE 为什么说 Java 语言“编译与解释并存”？ Oracle JDK 和 OpenJDK 的对比 Java 和 C++的区别? import java 和 javax 有什么区别？ 基本语法 字符型常量和字符串常量的区别? 注释 标识符和关键字的区别是什么？ Java 中有哪些常见的关键字？ 自增自减运算符 continue、break、和 return 的区别是什么？ Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？ ==和 equals 的区别 hashCode()与 equals() 基本数据类型 Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？ 自动装箱与拆箱 8 种基本类型的包装类和常量池 方法（函数） 什么是方法的返回值? 方法有哪几种类型？ 在一个静态方法内调用一个非静态成员为什么是非法的? 静态方法和实例方法有何不同？ 为什么 Java 中只有值传递？ 重载和重写的区别 重载 重写 深拷贝 vs 浅拷贝 Java 面向对象 面向对象和面向过程的区别 成员变量与局部变量的区别有哪些？ 创建一个对象用什么运算符?对象实体与对象引用有何不同? 对象的相等与指向他们的引用相等,两者有什么不同? 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么? 构造方法有哪些特点？是否可被 override? 面向对象三大特征 封装 继承 多态 String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的? Object 类的常见方法总结 反射 何为反射？ 反射机制优缺点 反射的应用场景 异常 Java 异常类层次结构图 Throwable 类常用方法 try-catch-finally 使用 try-with-resources 来代替try-catch-finally I\\O 流 什么是序列化?什么是反序列化? Java 序列化中如果有些字段不想进行序列化，怎么办？ 获取用键盘输入常用的两种方法 Java 中 IO 流分为几种? 既然有了字节流,为什么还要有字符流? 4. 参考 基础概念与常识Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 🐛 修正（参见： issue#544） ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用std::thread和std::async来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread JVM vs JDK vs JREJVMJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。 Java 程序从源代码到运行一般有下面 3 步： 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结： Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 JDK 和 JREJDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 为什么说 Java 语言“编译与解释并存”？高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。 Oracle JDK 和 OpenJDK 的对比可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。 对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案： 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？ 答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些闭源的第三方组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence 。 OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题； 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能； Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。 🌈 拓展一下： BCL 协议（Oracle Binary Code License Agreement）： 可以使用JDK（支持商用），但是不能进行修改。 OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的JDK用的都是这个协议，可以自己私下用，但是商用需要付费。 相关阅读👍：《Differences Between Oracle JDK and OpenJDK》 Java 和 C++的区别?我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。 C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。 …… import java 和 javax 有什么区别？刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。 所以，实际上 java 和 javax 没有区别。这都是一个名字。 基本语法字符型常量和字符串常量的区别? 形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符 含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节), 字符封装类 Character 有一个成员常量 Character.SIZE 值为 16,单位是bits,该值除以 8(1byte=8bits)后就可以得到 2 个字节 java 编程思想第四版：2.2.2 节 注释Java 中的注释有三种： 单行注释 多行注释 文档注释。 在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。 《Clean Code》这本书明确指出： 代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。 若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。 举个例子： 去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可 12// check to see if the employee is eligible for full benefitsif ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65)) 应替换为 1if (employee.isEligibleForFullBenefits()) 标识符和关键字的区别是什么？在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。 Java 中有哪些常见的关键字？ 分类 关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 自增自减运算符在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。 ++和–运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。 continue、break、和 return 的区别是什么？在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词： continue ：指跳出当前的这一次循环，继续下一次循环。 break ：指跳出整个循环体，继续执行循环下面的语句。 return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法： return; ：直接使用 return 结束方法执行，用于没有返回值函数的方法 return value; ：return 一个特定值，用于有返回值函数的方法 Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。 1234567891011List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(12);//这里直接添加会报错list.add(&quot;a&quot;);Class&lt;? extends List&gt; clazz = list.getClass();Method add = clazz.getDeclaredMethod(&quot;add&quot;, Object.class);//但是通过反射添加，是可以的add.invoke(list, &quot;kl&quot;);System.out.println(list); 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。 1.泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt; &#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey() &#123; return key; &#125;&#125; 如何实例化泛型类： 1Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); 2.泛型接口 ： 123public interface Generator&lt;T&gt; &#123; public T method();&#125; 实现泛型接口，不指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T method() &#123; return null; &#125;&#125; 实现泛型接口，指定类型： 123456class GeneratorImpl implements Generator&lt;String&gt;&#123; @Override public String method() &#123; return &quot;hello&quot;; &#125;&#125; 3.泛型方法 ： 123456public static &lt;E&gt; void printArray(E[] inputArray) &#123; for (E element : inputArray) &#123; System.out.printf(&quot;%s &quot;, element); &#125; System.out.println();&#125; 使用： 12345// 创建不同类型数组： Integer, Double 和 CharacterInteger[] intArray = &#123; 1, 2, 3 &#125;;String[] stringArray = &#123; &quot;Hello&quot;, &quot;World&quot; &#125;;printArray(intArray);printArray(stringArray); 常用的通配符为： T，E，K，V，？ ？ 表示不确定的 java 类型 T (type) 表示具体的一个 java 类型 K V (key value) 分别代表 java 键值中的 Key Value E (element) 代表 Element ==和 equals 的区别对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals() 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类。 Object 类 equals() 方法： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; equals() 方法存在两种使用情况： 类没有覆盖 equals()方法 ：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。 类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(&quot;ab&quot;); // a 为一个引用 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样 String aa = &quot;ab&quot;; // 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa == bb) // true System.out.println(&quot;aa==bb&quot;); if (a == b) // false，非同一对象 System.out.println(&quot;a==b&quot;); if (a.equals(b)) // true System.out.println(&quot;aEQb&quot;); if (42 == 42.0) &#123; // true System.out.println(&quot;true&quot;); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 String类equals()方法： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; hashCode()与 equals()面试官可能会问你：“你重写过 hashcode 和 equals么，为什么重写 equals 时必须重写 hashCode 方法？” 1)hashCode()介绍: hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 1public native int hashCode(); 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 2)为什么要有 hashCode？ 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 3)为什么重写 equals 时必须重写 hashCode 方法？ 如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？ 在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。 因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode )。 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 更多关于 hashcode() 和 equals() 的内容可以查看：Java hashCode() 和 equals()的若干问题解答 基本数据类型Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？Java 中有 8 种基本数据类型，分别为： 6 种数字类型 ：byte、short、int、long、float、double 1 种字符类型：char 1 种布尔型：boolean。 这 8 种基本数据类型的默认值以及所占空间的大小如下： 基本类型 位数 字节 默认值 int 32 4 0 short 16 2 0 long 64 8 0L byte 8 1 0 char 16 2 ‘u0000’ float 32 4 0f double 64 8 0d boolean 1 false 另外，对于 boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。 注意： Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析。 char a = &#39;h&#39;char :单引号，String a = &quot;hello&quot; :双引号。 这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。 包装类型不赋值就是 Null ，而基本类型有默认值且不是 Null。 另外，这个问题建议还可以先从 JVM 层面来分析。 基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。 《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 （boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 举例： 12Integer i = 10; //装箱int n = i; //拆箱 上面这两行代码对应的字节码为： 123456789101112131415161718192021222324252627L1 LINENUMBER 8 L1 ALOAD 0 BIPUSH 10 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;L2 LINENUMBER 9 L2 ALOAD 0 ALOAD 0 GETFIELD AutoBoxTest.i : Ljava/lang/Integer; INVOKEVIRTUAL java/lang/Integer.intValue ()I PUTFIELD AutoBoxTest.n : I RETURN 从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。 因此， Integer i = 10 等价于 Integer i = Integer.valueOf(10) int n = i 等价于 int n = i.intValue(); 8 种基本类型的包装类和常量池Java 基本类型的包装类的大部分都实现了常量池技术。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。 Integer 缓存源码： 12345678910111213141516171819202122232425/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[];&#125; Character 缓存源码: 12345678910111213141516171819202122232425262728293031public static Character valueOf(char c) &#123; if (c &lt;= 127) &#123; // must cache return CharacterCache.cache[(int)c]; &#125; return new Character(c);&#125;private static class CharacterCache &#123; private CharacterCache()&#123;&#125; static final Character cache[] = new Character[127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); &#125;&#125; Boolean 缓存源码： 12345public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE);&#125; 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 1234567891011121314151617Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false 下面我们来看一下问题。下面的代码的输出结果是 true 还是 flase 呢？ 12345Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2); Integer i1=40 这一行代码会发生装箱，也就是说这行代码等价于 Integer i1=Integer.valueOf(40) 。因此，i1 直接使用的是常量池中的对象。而Integer i1 = new Integer(40) 会直接创建新的对象。 因此，答案是 false 。你答对了吗？ 记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较。 方法（函数）什么是方法的返回值?方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！ 方法有哪几种类型？1.无参数无返回值的方法 1234// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)public void f1() &#123; System.out.println(&quot;无参数无返回值的方法&quot;);&#125; 2.有参数无返回值的方法 1234567/*** 有参数无返回值的方法* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开*/public void f2(int a, String b, int c) &#123; System.out.println(a + &quot;--&gt;&quot; + b + &quot;--&gt;&quot; + c);&#125; 3.有返回值无参数的方法 12345// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）public int f3() &#123; System.out.println(&quot;有返回值无参数的方法&quot;); return 2;&#125; 4.有返回值有参数的方法 1234// 有返回值有参数的方法public int f4(int a, int b) &#123; return a * b;&#125; 5.return 在无返回值方法的特殊使用 1234567// return在无返回值方法的特殊使用public void f5(int a) &#123; if (a &gt; 10) &#123; return;//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行 &#125; System.out.println(a);&#125; 在一个静态方法内调用一个非静态成员为什么是非法的?这个需要结合 JVM 的相关知识，静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，然后通过类的实例对象去访问。在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 静态方法和实例方法有何不同？1、调用方式 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。 不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。 因此，一般建议使用 类名.方法名 的方式来调用静态方法。 1234567891011121314151617public class Person &#123; public void method() &#123; //...... &#125; public static void staicMethod()&#123; //...... &#125; public static void main(String[] args) &#123; Person person = new Person(); // 调用实例方法 person.method(); // 调用静态方法 Person.staicMethod() &#125;&#125; 2、访问类成员是否存在限制 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 为什么 Java 中只有值传递？首先，我们回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。 按值调用(call by value) 表示方法接收的是调用者提供的值，按引用调用（call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言（不只是 Java）中方法参数传递方式。 Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(&quot;num1 = &quot; + num1); System.out.println(&quot;num2 = &quot; + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b);&#125; 结果： 1234a = 20b = 10num1 = 10num2 = 20 解析： 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);&#125;public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0;&#125; 结果： 1210 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student(&quot;小张&quot;); Student s2 = new Student(&quot;小李&quot;); Test.swap(s1, s2); System.out.println(&quot;s1:&quot; + s1.getName()); System.out.println(&quot;s2:&quot; + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println(&quot;x:&quot; + x.getName()); System.out.println(&quot;y:&quot; + y.getName()); &#125;&#125; 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 交换之后： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结 Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 参考： 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节 重载和重写的区别 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 下面是《Java 核心技术》对重载这个概念的介绍： 综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。 重写重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变 暖心的 Guide 哥最后再来个图表总结一下！ 区别点 重载方法 重写方法 发生范围 同一个类 子类 参数列表 必须修改 一定不能修改 返回类型 可修改 子类方法返回值类型应比父类方法返回值类型更小或相等 异常 可修改 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》,issue#892 ）： “两同”即方法名相同、形参列表相同； “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 ⭐️ 关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。 12345678910111213141516171819202122232425public class Hero &#123; public String name() &#123; return &quot;超级英雄&quot;; &#125;&#125;public class SuperMan extends Hero&#123; @Override public String name() &#123; return &quot;超人&quot;; &#125; public Hero hero() &#123; return new Hero(); &#125;&#125;public class SuperSuperMan extends SuperMan &#123; public String name() &#123; return &quot;超级超级英雄&quot;; &#125; @Override public SuperMan hero() &#123; return new SuperMan(); &#125;&#125; 深拷贝 vs 浅拷贝 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 Java 面向对象面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 参见 issue : 面向过程 ：面向过程性能比面向对象高？？ 这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。 而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。 成员变量与局部变量的区别有哪些？ 从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 对象的相等与指向他们的引用相等,两者有什么不同?对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?构造方法主要作用是完成对类对象的初始化工作。 如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 构造方法有哪些特点？是否可被 override?特点： 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。 构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 面向对象三大特征封装封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。 123456789101112131415161718192021222324public class Student &#123; private int id;//id属性私有化 private String name;//name属性私有化 //获取id的方法 public int getId() &#123; return id; &#125; //设置id的方法 public void setId(int id) &#123; this.id = id; &#125; //获取name的方法 public String getName() &#123; return name; &#125; //设置name的方法 public void setName(String name) &#123; this.name = name; &#125;&#125; 继承不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?可变性 简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以String 对象是不可变的。 补充（来自issue 675）：在 Java 9 之后，String 、StringBuilder 与 StringBuffer 的实现改用 byte 数组存储字符串 private final byte[] value 而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 1234567891011121314abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; /** * The count is the number of characters used. */ int count; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125;&#125; 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer Object 类的常见方法总结Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法： 1234567891011121314151617181920public final native Class&lt;?&gt; getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念protected void finalize() throws Throwable &#123; &#125;//实例被垃圾回收器回收的时候触发的操作 反射何为反射？如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。 反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。 反射机制优缺点 优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。Java Reflection: Why is it so slow? 反射的应用场景像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。 但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。 这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。 12345678910111213141516171819public class DebugInvocationHandler implements InvocationHandler &#123; /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); System.out.println(&quot;after method &quot; + method.getName()); return result; &#125;&#125; 另外，像 Java 中的一大利器 注解 的实现也用到了反射。 为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？ 这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 异常Java 异常类层次结构图 图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/ 图片来自：https://chercher.tech/java-programming/exceptions-java 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。 Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。 Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 受检查异常 Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException…。 不受检查异常 Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。 Throwable 类常用方法 public String getMessage():返回异常发生时的简要描述 public String toString():返回异常发生时的详细信息 public String getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同 public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息 try-catch-finally try块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块： 用于处理 try 捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在以下 3 种特殊情况下，finally 块不会被执行： 在 try 或 finally块中用了 System.exit(int)退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行 程序所在的线程死亡。 关闭 CPU。 下面这部分内容来自 issue:https://github.com/Snailclimb/JavaGuide/issues/190。 注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下： 1234567891011public class Test &#123; public static int f(int value) &#123; try &#123; return value * value; &#125; finally &#123; if (value == 2) &#123; return 0; &#125; &#125; &#125;&#125; 如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。 使用 try-with-resources 来代替try-catch-finally 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象 关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行 《Effecitve Java》中明确指出： 面对必须要关闭的资源，我们总是应该优先使用 try-with-resources 而不是try-finally。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。try-with-resources语句让我们更容易编写必须要关闭的资源的代码，若采用try-finally则几乎做不到这点。 Java 中类似于InputStream、OutputStream 、Scanner 、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下： 1234567891011121314//读取文本文件的内容Scanner scanner = null;try &#123; scanner = new Scanner(new File(&quot;D://read.txt&quot;)); while (scanner.hasNext()) &#123; System.out.println(scanner.nextLine()); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; finally &#123; if (scanner != null) &#123; scanner.close(); &#125;&#125; 使用 Java 7 之后的 try-with-resources 语句改造上面的代码: 1234567try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123; while (scanner.hasNext()) &#123; System.out.println(scanner.nextLine()); &#125;&#125; catch (FileNotFoundException fnfe) &#123; fnfe.printStackTrace();&#125; 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。 通过使用分号分隔，可以在try-with-resources块中声明多个资源。 12345678910try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123; int b; while ((b = bin.read()) != -1) &#123; bout.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; I/O 流什么是序列化?什么是反序列化?如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。 简单来说： 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。 维基百科是如是介绍序列化的： 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。 https://www.corejavaguru.com/java/serialization/interview-questions-1 Java 序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 关于 transient 还有几点注意： transient 只能修饰变量，不能修饰类和方法。 transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。 static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。 获取用键盘输入常用的两种方法方法 1：通过 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法 2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in));String s = input.readLine(); Java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： 既然有了字节流,为什么还要有字符流?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 4. 参考 https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre https://www.educba.com/oracle-vs-openjdk/ https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk 基础概念与常识","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}],"author":"Captt-g"},{"title":"CSS基础","slug":"计算机世界/CSS","date":"2021-11-03T14:27:04.895Z","updated":"2021-11-04T15:07:53.038Z","comments":true,"path":"2021/11/03/计算机世界/CSS/","link":"","permalink":"http://example.com/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/CSS/","excerpt":"","text":"语法简单的键值对语法但如果一个属性后面有多个值，可以使用空格隔开 CSS和Html的结合方式 行内样式：在某个特定的标签里采用style属性，范围只针对这个标签 内嵌样式表：在head中采用&lt;style&gt;标签，针对 此页面 引入外部样式表css文件： 采用import，必须写在style标签中，且必须是第一句，eg:@import url(c.css),可以在css样式表中使用 采用link，eg:&lt;link rel=&quot;stylesheet&quot; type:&quot;text/css&quot; href=&quot;a.css&quot;&gt;&lt;/link&gt; 的选择器基本选择器： 标签选择器：针对一类标签 id选择器：针对特定标签，#定义 类选择器：针对所有标签，.定义 通用选择器：针对所有标签，*定义id通常为js使用，所以css一般不用id，而是使用类选择，同时一般认为带有id的标签是动态的。高级选择器 后代选择器：用空格分开，eg: div div b,选择div中的有b字段的div的b字段 交集选择器：h3.special或者h3#special,.代表special类，#代表special id。 并集选择器：用,隔开eg：p,h1,#titles,.one选择p字段和h1字段和title id,和one类伪类选择器 静态伪类： ：link 超链接点击之前 ：visited 链接被访问之后 动态伪类 ：hover 悬停 ：active 激活，点击不松手的时候 ：focus 是某个标签获得焦点是，比如输入框焦点超链接a的四种状态 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt; /*让超链接点击之前是红色*/ a:link&#123; color:red; &#125; /*让超链接点击之后是绿色*/ a:visited&#123; color:orange; &#125; /*鼠标悬停，放到标签上的时候*/ a:hover&#123; color:green; &#125; /*鼠标点击链接，但是不松手的时候*/ a:active&#123; color:black; &#125;&lt;/style&gt; 必须按照顺序，否则会失效 font字体属性123456789p&#123; font-size: 50px; /*字体大小*/ line-height: 30px; /*行高*/ font-family: 幼圆,黑体; /*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/ font-style: italic ; /*italic表示斜体，normal表示不倾斜*/ font-weight: bold; /*粗体*/ font-variant: small-caps; /*小写变大写*/ vertical-align:middle; /*指定行级元素的垂直对齐方式*/&#125; overflow 属性处理超出范围的内容 visible：默认，全部显示 hidden：不显示超过对象尺寸的内容 auto： 如果内容不超出，不显示滚动条，否则显示滚动条。鼠标属性 auto:默认值。浏览器根据当前情况自动确定鼠标光标类型 pointer: 竖起一根手指的图标，鼠标在超链接上的图标123p:hover&#123; cursor:pointer;&#125; 滤镜可以对图片使用滤镜1&lt;img src=&quot;xxx.jpg&quot; style=&quot;filter:gray()&quot;&gt; css样式表的继承性 选择上了，数权重，(id的数量，类的数量，标签的数量)。如果权重一样，谁写在后面听谁的。 没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。 可以通过在属性后面添加!important增加权重到无穷大 1k:v !important; 但important无法提升继承的权重 盒子模型的主要属性 width 和h eight padding：内边距 border：边框 margin：外边距 标准文档流的特性行内元素和块级元素的区别 行内元素： 与其他元素并排 不能设置宽高，就是文字的宽度 块级元素 独占一行 能接受宽高的设置 可以通过display属性将行内元素和块级元素进行相互转换：inline和block 浮动","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}],"author":"Captt-g"},{"title":"html基础","slug":"计算机世界/html","date":"2021-11-02T14:20:52.299Z","updated":"2021-11-04T15:07:56.447Z","comments":true,"path":"2021/11/02/计算机世界/html/","link":"","permalink":"http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/html/","excerpt":"","text":"重要标签base标签： 1&lt;base href=&quot;/&quot;&gt; 用于指定基础的路径，指定以后，所有a连接都是以这个路径为基准。 文本级标签：p,span,a,b,i,u,em.文本级标签里只能放文字，图片，表单元素。 容器级标签：div,h系列,li,dt,dd.容器级标签中可以放任何东西。 水平线标签 &lt;hr/&gt;属性： align: 设定放置位置，left，right，center。 size：设定线条粗细，以像素为单位。 width：设定线条长度 color：设定线条颜色 noshade：不要阴影&lt;div&gt;和&lt;span&gt;标签div标签：可以把标签中的内容分割为独立的区块，必须单独占据一行。 span标签：}与div作用一直，但不换行字体标签特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp &lt; 小于号 &amp;lt &gt; 大于号 &amp;gt &amp; 和号 &amp;amp ￥ 人民币 &amp;yen © 版权 &amp;copy ® 注册商标 &amp;reg ° 摄氏度 &amp;deg ± 正负号 &amp;plusmn × 乘号 &amp;times ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 上标sup下标subp代表top，b代表bottom120&lt;sup&gt;2&lt;/sup&gt;5&lt;sub&gt;3&lt;/sub&gt; 超链接a是anchor“锚”的意思。链接到外部文件1&lt;a href=&quot;xxx.html&quot;&gt;进入外部链接&lt;/a&gt; 锚链接定位到页面的锚位置。1&lt;a href=&quot;a.html#name1&quot;&gt;去往name为name1所在位置&lt;/a&gt; 邮件链接1&lt;a href=&quot;mailto:xxx@126.com&quot;&gt;点击进入邮箱&lt;/a&gt; 超链接的属性 href：目标url title：悬停文本 name：设置一个锚点名称 target：设置用什么方式打开页面，_self,_blank,_parent,_top.图片标签样例：1&lt;img src=&quot;url&quot;/&gt; 属性 src：源文件 width：宽度 height：高度，只指定一个值，图片会自动进行缩放。 alt：当图片无法显示的时候，用alt中的内容替代 title：悬停提示 align：设置相对位置，bottom，center，top，left，right列表标签无序列表ul:unordered listli:list item 1234&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 有序列表ol:ordered list 1234&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ol&gt; 定义列表 dl:definition list dt:deifinition title dd:definition description123456&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;what&#x27;s up?&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;help me&lt;/dd&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 属性 border：像素为单位 style=”border-collapse:collapse;”：单元格的线和表格的边线框合并 bordercolor：表格的边框颜色 align：表格的水平对齐方式，而不是表格里内容的对齐方式，设置内容的对齐方式在td中设置 cellpadding：单元格内容到左边线的距离 cellspacing：单元格和单元格之间的距离（外边距） bgcolor：表格背景颜色 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left） 既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。tr 行属性 td 列属性 valign：一行的内容垂直方向排布，一般center单元格的合并 colspan：横向合并，colspan=2表示当前单元格在水平方向要占据两个单元格 rowspan：纵向合并，rowspan=2表示要在当前单元格垂直方向占据两个单元格html5 新增语义标签 section：表示区块 article：表示文章 header：表示页眉 footer：表示页脚 nav：表示导航 aside：表示侧边栏，如文章的侧栏 figure：表示媒介内容分组 mark：表示标记 progress：表示进度 time：表示日期","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}],"author":"Captt-g"},{"title":"用c++完成mac封装实验","slug":"计算机世界/mac封装","date":"2021-11-01T13:28:55.175Z","updated":"2021-11-01T14:01:46.709Z","comments":true,"path":"2021/11/01/计算机世界/mac封装/","link":"","permalink":"http://example.com/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/","excerpt":"","text":"MAC帧封装在终端输入数据，输出MAC帧包装后的相关信息。仅考虑单帧 MAC帧基本格式 前导码 帧定界符 目的地址 源地址 长度字段 数据字段 校验字段 7B 1B (6B) (6B) (2B) 46~1500字节 (4B) 题目条件目的地址：8000FF602CDC源地址：8000FE853A5F生成多项式： $$G(x)=x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$$ 程序思路 先通过已给条件填充数据的目的地址，原地址，数据字段，长度字段。 根据crc-32校验不包括前导码和定界符，通过已有数据计算出冗余码添加到mac末尾。 数据全部用string存储方便最后输出。 自己写hextobinary和binarytohex函数做数据转换。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Frame&#123;private: string Destination = &quot;8000FF602cdc&quot;; string Source = &quot;8000FE853a5f&quot;; string Divisor = &quot;100000100110000010001110110110111&quot;; string destinationBin = &quot;&quot;; string SourceBin = &quot;&quot;; string lengthField = &quot;&quot;; string data = &quot;&quot;; string dataBin = &quot;&quot;; string fcs = &quot;&quot;; string mac = &quot;&quot;; string macHex = &quot;&quot;; string fcsHex = &quot;&quot;; int macByteLenth = 18; string FOUR_BIT_BIN[16] = &#123; &quot;0000&quot;, &quot;0001&quot;, &quot;0010&quot;, &quot;0011&quot;, &quot;0100&quot;, &quot;0101&quot;, &quot;0110&quot;, &quot;0111&quot;, &quot;1000&quot;, &quot;1001&quot;, &quot;1010&quot;, &quot;1011&quot;, &quot;1100&quot;, &quot;1101&quot;, &quot;1110&quot;, &quot;1111&quot;&#125;; void input(); void dealWithDestinationAddress(); void dealWithSourceAddress(); void dealWithData(); void dealWithLengthField(); void dealWithFcs(); void dealWithMac(); string solveFcs(string dividend, string divisor); string dataToBinaryString(string data); string fillZero(string data, int finalBitLength, bool way); string hexToBinary(string hex); string binaryToHex(string binary); string toBinaryString(int num);public: void output(); void begin();&#125;;void Frame::begin()&#123; this-&gt;input(); this-&gt;dealWithDestinationAddress(); this-&gt;dealWithSourceAddress(); this-&gt;dealWithData(); this-&gt;dealWithLengthField(); this-&gt;mac += this-&gt;lengthField; this-&gt;mac += this-&gt;dataBin; this-&gt;dealWithFcs(); this-&gt;dealWithMac();&#125;void Frame::input()&#123; getline(cin, this-&gt;data); cout &lt;&lt; &quot;-----------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::output()&#123; cout &lt;&lt; &quot;MAC帧（二进制）为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;mac &lt;&lt; endl; cout &lt;&lt; &quot;目的地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Destination &lt;&lt; endl; cout &lt;&lt; &quot;原地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Source &lt;&lt; endl; cout &lt;&lt; &quot;长度为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macByteLenth &lt;&lt; endl; cout &lt;&lt; &quot;数据为:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;dataBin &lt;&lt; endl; cout &lt;&lt; &quot;FCS为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcs &lt;&lt; endl; cout &lt;&lt; &quot;MAC帧（十六进制）:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macHex &lt;&lt; endl; cout &lt;&lt; &quot;FCS(16进制):&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcsHex &lt;&lt; endl; cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::dealWithDestinationAddress()&#123; this-&gt;destinationBin = this-&gt;hexToBinary(this-&gt;Destination); this-&gt;mac += this-&gt;destinationBin;&#125;void Frame::dealWithSourceAddress()&#123; this-&gt;SourceBin = this-&gt;hexToBinary(this-&gt;Source); this-&gt;mac += this-&gt;SourceBin;&#125;void Frame::dealWithData()&#123; int dataByteLength = 0; this-&gt;dataBin = this-&gt;dataToBinaryString(data); dataByteLength = this-&gt;dataBin.size() / 8; if (dataByteLength &lt; 46) &#123; this-&gt;dataBin = this-&gt;fillZero(this-&gt;dataBin, 46 * 8, false); dataByteLength = 46; &#125; else if (dataByteLength &gt; 1500) &#123; cout &lt;&lt; &quot;输入超出范围&quot; &lt;&lt; endl; exit(0); &#125; this-&gt;macByteLenth += dataByteLength;&#125;void Frame::dealWithLengthField()&#123; this-&gt;lengthField = toBinaryString(this-&gt;macByteLenth); this-&gt;lengthField = this-&gt;fillZero(this-&gt;lengthField, 16, true);&#125;string Frame::toBinaryString(int num)&#123; string result = &quot;&quot;; while (num / 2 != 0) &#123; result.insert(0, to_string(num % 2)); num /= 2; &#125; result.insert(0, to_string(num)); return result;&#125;void Frame::dealWithFcs()&#123; string dividend = this-&gt;fillZero(this-&gt;mac, this-&gt;mac.length() + 32, false); this-&gt;fcs = this-&gt;solveFcs(dividend, this-&gt;Divisor); this-&gt;fcsHex = this-&gt;binaryToHex(this-&gt;fcs); this-&gt;mac += this-&gt;fcs;&#125;void Frame::dealWithMac()&#123; this-&gt;macHex = this-&gt;binaryToHex(this-&gt;mac);&#125;string Frame::solveFcs(string dividend, string divisor)&#123; string fcs = &quot;&quot;; int head = 0; int tail = head + divisor.length() - 1; int i; while (tail &lt; dividend.length()) &#123; if (&#x27;1&#x27; == dividend[head]) &#123; for (i = head; i &lt;= tail; i++) &#123; if (dividend[i] == divisor[i - head]) &#123; dividend[i] = &#x27;0&#x27;; &#125; else &#123; dividend[i] = &#x27;1&#x27;; &#125; &#125; &#125; head++; tail++; &#125; for (i = head; i &lt; dividend.length(); i++) &#123; fcs += dividend[i]; &#125; return fcs;&#125;string Frame::dataToBinaryString(string data)&#123; string result; string oneBit; for (int i = 0; i &lt; data.length(); i++) &#123; oneBit = toBinaryString(data[i]); oneBit = this-&gt;fillZero(oneBit, 8, true); result += oneBit; &#125; return result;&#125;string Frame::fillZero(string data, int finalBitLength, bool way)&#123; string result = &quot;&quot;; for (int i = data.length(); i &lt; finalBitLength; i++) &#123; result += &#x27;0&#x27;; &#125; if (way == true) &#123; result += data; &#125; else &#123; result = data + result; &#125; return result;&#125;string Frame::hexToBinary(string hex)&#123; string Binary = &quot;&quot;; int hexBitLength = hex.length(); for (int i = 0; i &lt; hexBitLength; i++) &#123; if (hex[i] &gt;= &#x27;0&#x27; &amp;&amp; hex[i] &lt;= &#x27;9&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;0&#x27;]; &#125; else if (hex[i] &gt;= &#x27;a&#x27; &amp;&amp; hex[i] &lt;= &#x27;z&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;a&#x27; + 10]; &#125; else &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;A&#x27; + 10]; &#125; &#125; return Binary;&#125;string Frame::binaryToHex(string binary)&#123; string binToHex = &quot;&quot;; string tmp = &quot;&quot;; for (size_t j = 0; j &lt; binary.size(); j += 4) &#123; tmp = binary.substr(j, 4); if (!tmp.compare(&quot;0000&quot;)) binToHex += &quot;0&quot;; else if (!tmp.compare(&quot;0001&quot;)) binToHex += &quot;1&quot;; else if (!tmp.compare(&quot;0010&quot;)) binToHex += &quot;2&quot;; else if (!tmp.compare(&quot;0011&quot;)) binToHex += &quot;3&quot;; else if (!tmp.compare(&quot;0100&quot;)) binToHex += &quot;4&quot;; else if (!tmp.compare(&quot;0101&quot;)) binToHex += &quot;5&quot;; else if (!tmp.compare(&quot;0110&quot;)) binToHex += &quot;6&quot;; else if (!tmp.compare(&quot;0111&quot;)) binToHex += &quot;7&quot;; else if (!tmp.compare(&quot;1000&quot;)) binToHex += &quot;8&quot;; else if (!tmp.compare(&quot;1001&quot;)) binToHex += &quot;9&quot;; else if (!tmp.compare(&quot;1010&quot;)) binToHex += &quot;A&quot;; else if (!tmp.compare(&quot;1011&quot;)) binToHex += &quot;B&quot;; else if (!tmp.compare(&quot;1100&quot;)) binToHex += &quot;C&quot;; else if (!tmp.compare(&quot;1101&quot;)) binToHex += &quot;D&quot;; else if (!tmp.compare(&quot;1110&quot;)) binToHex += &quot;E&quot;; else if (!tmp.compare(&quot;1111&quot;)) binToHex += &quot;F&quot;; else continue; &#125; return binToHex;&#125;//稍显丑陋。。。int main()&#123; Frame frame; frame.begin(); frame.output();&#125; 实现截图","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"香农公式术语","slug":"计算机世界/香农公式术语","date":"2021-10-27T08:56:00.203Z","updated":"2021-10-27T09:01:09.919Z","comments":true,"path":"2021/10/27/计算机世界/香农公式术语/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/","excerpt":"","text":"波特率波特率（也称信息传送速率、码元速率、符号速率、传码率），其定义为每秒钟传送码元的数目，码元速率的单位为“波特”，常用符号“Baud”表示，简写为“B”。 一个数字脉冲就是一个码元，我们用码元速率表示单位时间内信号波形的变换次数，即单位时间内通过信道传输的码元个数。若信号码元宽度为T秒，则码元速率B为：$$B = 1/T(Baud)$$ 比特率比特率也称数据传输速率，它的定义是单位时间内可以传输的比特数，单位为bps。比特率的计算公式为：$$\\mbox{比特率}=\\mbox{波特率}*\\mbox{每码元含有的bit数}$$ 怎么理解比特率和波特率之间的关系呢？我们可以假设一个信号只有两个电平状态，那么这个时候可以把低电平理解为“0”，高电平理解为“1”，这样每秒钟电平变化的次数也就是传输的0，1个数了，即比特率 = 波特率。但是有些信号可能不止两个电平，比如一个四电平的信号状态，那么每个电平就可以被理解成“00”，“01”，“10”，“11”，这样每次电平变化就能传输两位的数据了，即比特率 = 2 × 波特率。 带宽和容量带宽：一般信道都有一个最高的信号频率（频率是指每秒钟的周期数，而每个周期都会有几次电平变化）和最低的信号频率，只有在这两个频率之间的信号才能通过这个信道，这两个频率的差值就叫做这个信道的带宽，单位是Hz。 信道的容量：数据在信道中传输会有他们的速度——比特率，这里面最高的比特率就叫做这个信道的容量，单位是bps。 口语中也会把信道容量叫做“带宽”的，比如“带宽10M的网络”，“网络带宽是10M”等等。所以这两个概念也很容易混淆：我们平常所说的“带宽”不是带宽，而是信道容量，这一点心里要清楚.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"计算机网络","slug":"计算机世界/WireLine","date":"2021-10-27T01:38:37.020Z","updated":"2021-11-02T09:51:29.730Z","comments":true,"path":"2021/10/27/计算机世界/WireLine/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/WireLine/","excerpt":"","text":"物理层物理层基本概念物理层：解决怎样在连接各种计算机的传输媒体上传输数据比特流，而不指定具体的媒体。 物理层的任务：机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列固定和锁定装置等。电器特性：指明接口电缆中各条线上出现的电压范围。功能特性：指明某条线上出现某一电平的电压的意义。过程特性：指明对于不同功能的各种可能事件出现的顺序。转换任务：将并行数据转换为串行数据。 数据通信的基本知识数据通信系统： 源系统：分为源点，发送器（调制器） 传输系统：传输网络 目的系统：接收器（解调器），终点 常用术语：消息：例如语音，文字，图片等。数据：运送消息的载体。信号：数据的电气或电磁表现。模拟信号：连续的信号。数字信号：离散的信号。码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 关于信道的基本概念：定义：用来表示向某一个方向传送信息的媒体。交互方式：单工，半双工，全双工。基带信号：来自信源的信号称为基带信号，一般包含较多的低频成分，甚至有直流成分，许多信道不能传输这种低频分量和直流分量，所以必须对基带信号进行调制。 调制： 基带调制（编码）：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号。 带通调制：通过使用载波进行调制，将基带信号搬移到较高频段，并转换为模拟信号。转换完后的信号称为带通信号。 常用的编码方式： 不归零制：正电平代表1，负电平代表0.（没有自同步能力，不能从信号波形本身提取出信号的时钟频率）。 归零制：正脉冲代表1，负脉冲代表0。 曼彻斯特编码：为中心周期向下跳变代表1，向下跳变代表0。（也可以反过来） 差分曼彻斯特编码：在每一位中心始终都有跳变，位开始边界有跳变代表0，没有跳变代表1。 基本的带通调制方法： 调幅（AM）：即载波的振幅随基带数字信号变化。 调频（FM）：即载波的频率随基带的数字信号变化。 调相（PM）：即载波的初始相位随基带的数字型号变化。 为提高信息的传输速率，通常使用正交振幅调制（一个码元代表多个bit）。 信道的极限容量传输质量：码元的传输速率越高，或传输的距离越远，或噪声干扰越大，则传输媒体质量越大，失真越严重。 码间干扰：在接受端收到的信号波形失去了码元之间清晰的界限。 奈氏准则在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间干扰，使接受端识别数据称为不可能。 信噪比定义：信号的平均功率和噪声的平均功率之比，常记为$ S/N $,并用分贝（dB）作为度量单位。即：$$\\mbox{信噪比}(dB) = 10 \\log_{10}(S/N)(dB)$$ 香农公式$$C = W \\log_2(1+S/N)(bit/s)$$其中 W 为信道带宽，单位为（Hz），C为信道的极限传输速率，香农公式表明，信道的带宽或者信道的信噪比越大，信息的极限传输速率就越高。 术语https://please.sendmeto.icu/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/ 信道复用技术频分复用：相同时间不同频率时分复用：不同时间相同频率，将一个复用帧分为多个时隙，每个时隙分配给一个用户统计时分复用：动态分配的时分复用波分复用：光的频分复用，每隔120km添加一个放大器，可保证光信号不会衰减到不能被识别码分复用：各用户使用经过特殊挑选的不同码型，进行通信。 码分多址特点：很强的抗干扰能力，频谱类似于白噪声，不易被敌人发现。现在多使用在无线网中。复用方式：每一个比特时间再划分为m个短的间隔，称为码片，通常m的值为64或者128，使用CDMA的每个站被指派一个唯一的m bit的码片序列，一个站如果要发送1，则发送它自身的码片序列，如果要发送0，则发送自身码片序列的反码。惯例将码片中的0写作-1，将1写作+1.不同的码片序列必须相互正交。因为不同的码片序列之间是相互正交的，设S站的码片序列为S，T站的码片序列为T。$$S * T = 1/m \\Sigma S_i T_i = 0$$$$S * S = 1/m \\Sigma S_i^2 = 1$$因此如果S发射1，则接受方用$S * S$ 会得到1，如果S发射0，则接受方用$S * S$会得到-1.用此方法，如果接受方有S的码片序列，那么就可以收到A发射的消息。 数据链路层主要内容： 点对点信道和广播信道的特点，以及这两种信道所使用的协议的特点(PPP 协议一节 CSMA/CD 协议)。 数据链路层的三个基本问题：封装成帧，透明传输和差错检验。 以太网MAC层的硬件地址 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。 使用点对点信道的数据链路层数据链路和链路的区别： 链路：是从一个结点到相邻结点的一段物理线路（有线或者无线），而中间没有任何其他的交换结点。 数据链路：把视线协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层的协议数据单元：帧网络层的协议数据单元：IP数据报 点对点信道的数据链路层在进行通行的时候主要步骤： 结点A的数据链路层把网络层传下来的数据封装成帧 结点A把帧传输给结点B的数据链路层 结点B检验帧无差错，接受帧，否则丢弃帧 封装成帧在一段数据的前后分别添加首部和尾部，构成一个帧。首部SOH(Start Of Header),尾部EOT(End Of Transmission)是两种控制字符，并不是三个字符，在键盘中都不可输入。用于帧定界。 透明传输保证数据的完整性不因为数据中含有和定界符而在传输中丢失。 具体做法：发送端的数据链路层在数据中出现控制字符”SOH”,”EOT”,”ESC”的前面添加一个转移字符”ESC”，而在接受端的数据链路层删除这个转义字符，这种方法称为字符填充或者字节填充（byte stuffing）。 差错检验误码率：传输错误bit数占传输bit总数的比率CRC(Cyclic Redundancy Check)循环冗余检验技术被广泛用于数据链路层差错检验。检验方法： $$( M * 2^n ) / P= Q……R$$ 发送$M * 2^n + R$,接收方把每一帧都除以P，若余数为零则代表没有出现差错，否则代表出现差错，该式子中所有的除法均代表模二除法。其中P是n+1位二进制数，R是n位二进制数，被称作FCS(Frame Check Sequence)(冗余码，帧检验序列)。 CRC只能检测出bit差错，所以并不能进行可靠传输，如果想进行可靠传输，还需要增加帧编号，确认和重传机制，防止帧丢失，帧重复，帧失序。 详见https://please.sendmeto.icu/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/ 拓展以太网在数据链路层拓展以太网早期使用网桥，现在使用以太网交换机。==网桥==：根据mac帧的目的地址和地址表（交换表）对收到的帧进行转发和过滤。 ==以太网交换机==：实质是多接口网桥，内部地址表是通过自学习算法逐渐建立起来的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"LeetCode刷题记录","slug":"计算机世界/LeetCode","date":"2021-10-26T07:02:03.751Z","updated":"2021-10-26T13:08:54.228Z","comments":true,"path":"2021/10/26/计算机世界/LeetCode/","link":"","permalink":"http://example.com/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/LeetCode/","excerpt":"","text":"287. Find the Duplicate Number题目大意：给n+1个int值,1 &lt;= value &lt;= n,找出它们中的重复数字,时间复杂度为O(n^2),空间复杂度为O(1). 解决方法：使用二分法,记数组最大值，中值，最小值分别为max，mid，low，如果小于mid的数超过mid个，则重复的数字小于mid，否则大于mid。重复此过程。 123456789101112131415161718192021222324252627int findDuplicate(int *nums, int numsSize)&#123; int low = 0; int high = numsSize - 1; while (low &lt; high) &#123; int mid = (low + high) / 2; int count = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &lt;= mid) &#123; count++; &#125; &#125; if (count &gt; mid) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; return low;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"经典诗词","slug":"诗词世界/诗词世界","date":"2021-10-26T06:20:06.541Z","updated":"2021-11-02T15:09:29.599Z","comments":true,"path":"2021/10/26/诗词世界/诗词世界/","link":"","permalink":"http://example.com/2021/10/26/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/","excerpt":"","text":"临安春雨初霁（陆游)世味年来薄似纱，谁令骑马客京华。 小楼一夜听春雨，深巷明朝卖杏花。 矮纸斜行闲作草，晴窗细乳戏分茶。 素衣莫起风尘叹，犹及清明可到家。 临江仙·滚滚长江东逝水（杨慎）滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。","categories":[],"tags":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"}],"author":"Captt-g"},{"title":"JavaScript 基础语法学习笔记","slug":"计算机世界/JavaScript基础知识","date":"2021-10-25T13:15:22.546Z","updated":"2021-11-02T14:21:54.273Z","comments":true,"path":"2021/10/25/计算机世界/JavaScript基础知识/","link":"","permalink":"http://example.com/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"严格模式1&#x27;use strict&#x27;; 用break/continue和标签跳出多重循环只有在循环内部使用才可以调到标签所在位置。 123456outer: for(...)&#123; for(...)&#123; if(...) break outer;//从这里直接运行到alert &#125;&#125;alert(&#x27;Done!&#x27;) 函数箭头函数 12let func = ( arg1, arg2, ...argN)=&gt; expressionlet func = ( arg1, arg2, ...argN)=&gt; &#123; body &#125; 使用参数对expression求值并返回结果。等同于 123let func = function( arg1, arg2,... argN)&#123; return expression;&#125;; 例子 1let sum = ( a, b) =&gt; a + b; 对象js中的对象是一组键值对数据。 12345678910//创建空的对象let user=new Object();let user=&#123; name:&quot;John&quot;, age:30, &quot;like birds&quot;:true,&#125;;//删除属性delete user.age;alert(user[&quot;like birds&quot;]); 属性的命名没有限制，可以是任何字符串或者symbol，若命名数字也会被转换为字符串。 当被访问的属性不存在的时候会返回undefined。 计算属性当创建一个对象的时候，可以在对象字面量中使用方括号。 12345678910let fruit = prompt(&quot;Which fruit to buy?&quot;,&quot;apple&quot;);let bag=&#123; [fruit]:5,&#125;;alert(bag[fruit])//在方括号中使用更复杂的表达式let bag = &#123; [fruit+&#x27;Computers&#x27;]:5 ,&#125; 对象的克隆和引用对象名是对对象的引用，指向的是地址想要复制对象，可以使用 1Object.assign(dest, [src1, src2, src3...]) 该式子会把源对象的属性全部复制进dest 箭头函数没有自己的this箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。 123456789let user = &#123; firstName: &quot;Ilya&quot;, sayHi() &#123; let arrow = () =&gt; alert(this.firstName); arrow(); &#125;&#125;;user.sayHi(); // Ilya 这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用。 构造函数构造函数的两个约定： 命名以大写字母开头。 只能由new操作符来执行12345678function User(name)&#123; this.name=name; this.isAdmin=false;&#125;let user = new User(&quot;Jack&quot;);alert(user.name);alert(user.isAdmin); 从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"Captt-g"},{"title":"排序算法","slug":"计算机世界/Sort","date":"2021-10-24T13:10:15.993Z","updated":"2021-10-26T07:02:47.368Z","comments":true,"path":"2021/10/24/计算机世界/Sort/","link":"","permalink":"http://example.com/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/Sort/","excerpt":"","text":"插入排序 概念：0~p-1位置的数是排好序的，将第p位置上的数插入进排好序的数列里，形成新的排好序的数列。 12345678910void InsertSort(ElementType a[],int n)&#123; for(int i=1;i&lt;n;i++)&#123; ElementType tmp=a[i]; int j; for(j=i;j&gt;0&amp;&amp;a[j-1]&gt;tmp;j--)&#123; a[j]=a[j-1]; &#125; a[j]=tmp; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"当一个人","slug":"杂项/beaman","date":"2021-10-22T08:41:13.470Z","updated":"2021-10-24T15:05:35.571Z","comments":true,"path":"2021/10/22/杂项/beaman/","link":"","permalink":"http://example.com/2021/10/22/%E6%9D%82%E9%A1%B9/beaman/","excerpt":"","text":"当一个人 从明天开始我要当一个不再摆烂的人，早睡早起，每天吃早饭，认真看书学习，只在周末打游戏。","categories":[],"tags":[],"author":"Captt-g"}],"categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]}