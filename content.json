{"meta":{"title":"Captt-g","subtitle":"","description":"","author":"Captt-g","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-24T13:47:14.027Z","updated":"2021-10-24T13:47:14.027Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"ME!","date":"2021-10-25T05:42:56.011Z","updated":"2021-10-25T05:42:56.011Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个普通大学生，喜欢打羽毛球。","author":"Captt-g"},{"title":"所有标签","date":"2021-10-25T05:19:37.526Z","updated":"2021-10-25T05:19:37.526Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-25T05:21:19.616Z","updated":"2021-10-25T05:21:19.616Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-10-25T06:48:15.750Z","updated":"2021-10-25T06:48:15.750Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"Captt-g"},{"title":"所有分类","date":"2021-10-25T05:20:49.987Z","updated":"2021-10-25T05:20:49.987Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"5.Longest Palind romeSubstr","slug":"计算机世界/LongestPalind","date":"2021-11-24T09:58:00.443Z","updated":"2021-11-24T10:08:32.804Z","comments":true,"path":"2021/11/24/计算机世界/LongestPalind/","link":"","permalink":"http://example.com/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/LongestPalind/","excerpt":"","text":"题目大意给一个字符串，找出字符串中最长的回文串 动态规划法 dp[i][j]用于表示第i到第j个字符的字符串是否是回文串，因为一个回文串去掉首尾字符还是一个回文串，所以dp[i][j]=(s[i]==s[j])&amp;&amp;(j-i&lt;3||dp[i+1][j-1]),当j-i=1的时候表示仅有两个字符，只用保证s[i]==s[j]就可以，当j-i=2的时候，表示一共三个字符，只用保证中间字符两边相同就可以，也是s[i]==s[j]. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//answer.gofunc longestPalindrome(s string) string &#123; length :=len(s) res,dp:=&quot;&quot;,make([][]bool, length) for i := 0; i &lt; length; i++ &#123; dp[i]=make([]bool,length) &#125; for i:=length-1;i&gt;=0;i--&#123; for j:=i;j&lt;length;j++&#123; dp[i][j]=(s[i]==s[j])&amp;&amp;(j-i&lt;3||dp[i+1][j-1]) if dp[i][j]&amp;&amp;(j-i+1&gt;=len(res)||res==&quot;&quot;) &#123; res=s[i:j+1] &#125; &#125; &#125; return res&#125; //answer_test.goimport ( &quot;github.com/stretchr/testify/assert&quot; &quot;testing&quot;)func Test_question(t *testing.T) &#123; assertions:=assert.New(t) t.Run(&quot;test 1&quot;, func(t *testing.T) &#123; s:=&quot;babad&quot; got:=longestPalindrome(s) want:=&quot;bab&quot; assertions.Equal(want,got,&quot;check default&quot;) &#125;) t.Run(&quot;test 2&quot;, func(t *testing.T) &#123; s:=&quot;cbbd&quot; got:=longestPalindrome(s) want:=&quot;bb&quot; assertions.Equal(want,got,&quot;check default&quot;) &#125;) t.Run(&quot;test 3&quot;, func(t *testing.T) &#123; s:=&quot;a&quot; got:=longestPalindrome(s) want:=&quot;a&quot; assertions.Equal(want,got,&quot;check default&quot;) &#125;) t.Run(&quot;test 4&quot;, func(t *testing.T) &#123; s:=&quot;ac&quot; got:=longestPalindrome(s) want:=&quot;a&quot; assertions.Equal(want,got,&quot;check default&quot;) &#125;)&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"django初探","slug":"计算机世界/django","date":"2021-11-08T06:42:02.168Z","updated":"2021-11-09T10:25:02.879Z","comments":true,"path":"2021/11/08/计算机世界/django/","link":"","permalink":"http://example.com/2021/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/django/","excerpt":"","text":"start 安装django 创建项目：在一个空文件夹下运行django-admin startproject mysitename. 切换到 mysitename 然后运行python manage.py runserver.可以测试是否创建成功 更换端口：python manage.py runserver 8000 创建app：python manage.py startapp myapp 模型model文件django会根据模型里的代码自动生成相应的数据库数据 12python manage.py makemigrations polls #Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次迁移python manage.py migrate polls #在数据库里创建新定义的模型的数据表 写一个视图一个视图函数需要返回一个HttpResponse用于显示html网页。 1234from django.http import HttpResponsedef index(request): return HttpResponse(&#x27;hello world&#x27;) 一般在app目录下建立templates文件夹用于保存模板页面在你刚刚创建的 templates 目录里，再创建一个目录 appname，然后在其中新建一个文件 index.html。","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"}],"author":"Captt-g"},{"title":"JAVA","slug":"计算机世界/JAVA","date":"2021-11-05T00:39:08.520Z","updated":"2021-11-05T09:18:00.556Z","comments":true,"path":"2021/11/05/计算机世界/JAVA/","link":"","permalink":"http://example.com/2021/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/JAVA/","excerpt":"","text":"","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}],"author":"Captt-g"},{"title":"CSS基础","slug":"计算机世界/CSS","date":"2021-11-03T14:27:04.895Z","updated":"2021-11-08T03:51:41.380Z","comments":true,"path":"2021/11/03/计算机世界/CSS/","link":"","permalink":"http://example.com/2021/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/CSS/","excerpt":"","text":"语法简单的键值对语法但如果一个属性后面有多个值，可以使用空格隔开 CSS和Html的结合方式 行内样式：在某个特定的标签里采用style属性，范围只针对这个标签 内嵌样式表：在head中采用&lt;style&gt;标签，针对 此页面 引入外部样式表css文件： 采用import，必须写在style标签中，且必须是第一句，eg:@import url(c.css),可以在css样式表中使用 采用link，eg:&lt;link rel=&quot;stylesheet&quot; type:&quot;text/css&quot; href=&quot;a.css&quot;&gt;&lt;/link&gt; 的选择器基本选择器： 标签选择器：针对一类标签 id选择器：针对特定标签，#定义 类选择器：针对所有标签，.定义 通用选择器：针对所有标签，*定义id通常为js使用，所以css一般不用id，而是使用类选择，同时一般认为带有id的标签是动态的。高级选择器 后代选择器：用空格分开，eg: div div b,选择div中的有b字段的div的b字段 交集选择器：h3.special或者h3#special,.代表special类，#代表special id。 并集选择器：用,隔开eg：p,h1,#titles,.one选择p字段和h1字段和title id,和one类伪类选择器 静态伪类： ：link 超链接点击之前 ：visited 链接被访问之后 动态伪类 ：hover 悬停 ：active 激活，点击不松手的时候 ：focus 是某个标签获得焦点是，比如输入框焦点超链接a的四种状态 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt; /*让超链接点击之前是红色*/ a:link&#123; color:red; &#125; /*让超链接点击之后是绿色*/ a:visited&#123; color:orange; &#125; /*鼠标悬停，放到标签上的时候*/ a:hover&#123; color:green; &#125; /*鼠标点击链接，但是不松手的时候*/ a:active&#123; color:black; &#125;&lt;/style&gt; 必须按照顺序，否则会失效 font字体属性123456789p&#123; font-size: 50px; /*字体大小*/ line-height: 30px; /*行高*/ font-family: 幼圆,黑体; /*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/ font-style: italic ; /*italic表示斜体，normal表示不倾斜*/ font-weight: bold; /*粗体*/ font-variant: small-caps; /*小写变大写*/ vertical-align:middle; /*指定行级元素的垂直对齐方式*/&#125; overflow 属性处理超出范围的内容 visible：默认，全部显示 hidden：不显示超过对象尺寸的内容 auto： 如果内容不超出，不显示滚动条，否则显示滚动条。鼠标属性 auto:默认值。浏览器根据当前情况自动确定鼠标光标类型 pointer: 竖起一根手指的图标，鼠标在超链接上的图标123p:hover&#123; cursor:pointer;&#125; 滤镜可以对图片使用滤镜1&lt;img src=&quot;xxx.jpg&quot; style=&quot;filter:gray()&quot;&gt; css样式表的继承性 选择上了，数权重，(id的数量，类的数量，标签的数量)。如果权重一样，谁写在后面听谁的。 没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。 可以通过在属性后面添加!important增加权重到无穷大 1k:v !important; 但important无法提升继承的权重 盒子模型的主要属性 width 和h eight padding：内边距 border：边框 margin：外边距 标准文档流的特性行内元素和块级元素的区别 行内元素： 与其他元素并排 不能设置宽高，就是文字的宽度 块级元素 独占一行 能接受宽高的设置 可以通过display属性将行内元素和块级元素进行相互转换：inline和block 浮动性质一设置float属性，如果一个元素设置浮动后，那么它既可以并排，也可以设置宽高，无论它原来是div还是span。既不再区分行级和块级 性质二浮动的元素相互贴靠，同时浮动可以造成字围效果，既浮动的块不会遮挡文字 性质三浮动的元素如果没有设置width，就会自动收缩为内容的宽度。 清除浮动影响 如果一个元素浮动，那么他的祖先元素一定要有高度，有高度的盒子，才能管住浮动。 或者使用clear:both;使左右两边都不可以有浮动。 内墙法 overflow:hidden;作为偏方是浮动的子模块可以撑起父模块。 margin塌陷/margin重叠垂直方向上的margin是不叠加的，取最大的margin，水平方向上的margin叠加。如果盒子都浮动了，则两个盒子之间是没有塌陷现象的 盒子居中1margin: 0 auto; 只有标准流的盒子可以居中 盒子居中必须要有width 盒子居中用margin，盒子中的文本居中要用text-align:center. 要善于使用父亲的padding属性代替儿子的margin属性，因为父亲没有设置border的时候，儿子使用margin会出现错误。 定位属性","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}],"author":"Captt-g"},{"title":"html基础","slug":"计算机世界/html","date":"2021-11-02T14:20:52.299Z","updated":"2021-11-10T06:09:46.052Z","comments":true,"path":"2021/11/02/计算机世界/html/","link":"","permalink":"http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/html/","excerpt":"","text":"重要标签base标签： 1&lt;base href=&quot;/&quot;&gt; 用于指定基础的路径，指定以后，所有a连接都是以这个路径为基准。 文本级标签：p,span,a,b,i,u,em.文本级标签里只能放文字，图片，表单元素。 容器级标签：div,h系列,li,dt,dd.容器级标签中可以放任何东西。 水平线标签 &lt;hr/&gt;属性： align: 设定放置位置，left，right，center。 size：设定线条粗细，以像素为单位。 width：设定线条长度 color：设定线条颜色 noshade：不要阴影&lt;div&gt;和&lt;span&gt;标签div标签：可以把标签中的内容分割为独立的区块，必须单独占据一行。 span标签：}与div作用一直，但不换行字体标签特殊字符 特殊字符 描述 字符的代码 空格符 &amp;nbsp &lt; 小于号 &amp;lt &gt; 大于号 &amp;gt &amp; 和号 &amp;amp ￥ 人民币 &amp;yen © 版权 &amp;copy ® 注册商标 &amp;reg ° 摄氏度 &amp;deg ± 正负号 &amp;plusmn × 乘号 &amp;times ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 上标sup下标subp代表top，b代表bottom120&lt;sup&gt;2&lt;/sup&gt;5&lt;sub&gt;3&lt;/sub&gt; 超链接a是anchor“锚”的意思。链接到外部文件1&lt;a href=&quot;xxx.html&quot;&gt;进入外部链接&lt;/a&gt; 锚链接定位到页面的锚位置。1&lt;a href=&quot;a.html#name1&quot;&gt;去往name为name1所在位置&lt;/a&gt; 邮件链接1&lt;a href=&quot;mailto:xxx@126.com&quot;&gt;点击进入邮箱&lt;/a&gt; 超链接的属性 href：目标url title：悬停文本 name：设置一个锚点名称 target：设置用什么方式打开页面，_self,_blank,_parent,_top.图片标签样例：1&lt;img src=&quot;url&quot;/&gt; 属性 src：源文件 width：宽度 height：高度，只指定一个值，图片会自动进行缩放。 alt：当图片无法显示的时候，用alt中的内容替代 title：悬停提示 align：设置相对位置，bottom，center，top，left，right列表标签无序列表ul:unordered listli:list item 1234&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 有序列表ol:ordered list 1234&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ol&gt; 定义列表 dl:definition list dt:deifinition title dd:definition description123456&lt;dl&gt; &lt;dt&gt;第一条&lt;/dt&gt; &lt;dd&gt;what&#x27;s up?&lt;/dd&gt; &lt;dt&gt;第二条&lt;/dt&gt; &lt;dd&gt;help me&lt;/dd&gt;&lt;/dl&gt; 表格标签1234567891011121314151617181920212223&lt;table&gt; &lt;tr&gt; &lt;td&gt;生命壹号&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;黄冈&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;许嵩&lt;/td&gt; &lt;td&gt;29&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;安徽&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邓紫棋&lt;/td&gt; &lt;td&gt;23&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;香港&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 属性 border：像素为单位 style=”border-collapse:collapse;”：单元格的线和表格的边线框合并 bordercolor：表格的边框颜色 align：表格的水平对齐方式，而不是表格里内容的对齐方式，设置内容的对齐方式在td中设置 cellpadding：单元格内容到左边线的距离 cellspacing：单元格和单元格之间的距离（外边距） bgcolor：表格背景颜色 dir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left） 既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。tr 行属性 td 列属性 valign：一行的内容垂直方向排布，一般center单元格的合并 colspan：横向合并，colspan=2表示当前单元格在水平方向要占据两个单元格 rowspan：纵向合并，rowspan=2表示要在当前单元格垂直方向占据两个单元格html5 新增语义标签 section：表示区块 article：表示文章 header：表示页眉 footer：表示页脚 nav：表示导航 aside：表示侧边栏，如文章的侧栏 figure：表示媒介内容分组 mark：表示标记 progress：表示进度 time：表示日期","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}],"author":"Captt-g"},{"title":"用c++完成mac封装实验","slug":"计算机世界/mac封装","date":"2021-11-01T13:28:55.175Z","updated":"2021-11-01T14:01:46.709Z","comments":true,"path":"2021/11/01/计算机世界/mac封装/","link":"","permalink":"http://example.com/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/","excerpt":"","text":"MAC帧封装在终端输入数据，输出MAC帧包装后的相关信息。仅考虑单帧 MAC帧基本格式 前导码 帧定界符 目的地址 源地址 长度字段 数据字段 校验字段 7B 1B (6B) (6B) (2B) 46~1500字节 (4B) 题目条件目的地址：8000FF602CDC源地址：8000FE853A5F生成多项式： $$G(x)=x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$$ 程序思路 先通过已给条件填充数据的目的地址，原地址，数据字段，长度字段。 根据crc-32校验不包括前导码和定界符，通过已有数据计算出冗余码添加到mac末尾。 数据全部用string存储方便最后输出。 自己写hextobinary和binarytohex函数做数据转换。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Frame&#123;private: string Destination = &quot;8000FF602cdc&quot;; string Source = &quot;8000FE853a5f&quot;; string Divisor = &quot;100000100110000010001110110110111&quot;; string destinationBin = &quot;&quot;; string SourceBin = &quot;&quot;; string lengthField = &quot;&quot;; string data = &quot;&quot;; string dataBin = &quot;&quot;; string fcs = &quot;&quot;; string mac = &quot;&quot;; string macHex = &quot;&quot;; string fcsHex = &quot;&quot;; int macByteLenth = 18; string FOUR_BIT_BIN[16] = &#123; &quot;0000&quot;, &quot;0001&quot;, &quot;0010&quot;, &quot;0011&quot;, &quot;0100&quot;, &quot;0101&quot;, &quot;0110&quot;, &quot;0111&quot;, &quot;1000&quot;, &quot;1001&quot;, &quot;1010&quot;, &quot;1011&quot;, &quot;1100&quot;, &quot;1101&quot;, &quot;1110&quot;, &quot;1111&quot;&#125;; void input(); void dealWithDestinationAddress(); void dealWithSourceAddress(); void dealWithData(); void dealWithLengthField(); void dealWithFcs(); void dealWithMac(); string solveFcs(string dividend, string divisor); string dataToBinaryString(string data); string fillZero(string data, int finalBitLength, bool way); string hexToBinary(string hex); string binaryToHex(string binary); string toBinaryString(int num);public: void output(); void begin();&#125;;void Frame::begin()&#123; this-&gt;input(); this-&gt;dealWithDestinationAddress(); this-&gt;dealWithSourceAddress(); this-&gt;dealWithData(); this-&gt;dealWithLengthField(); this-&gt;mac += this-&gt;lengthField; this-&gt;mac += this-&gt;dataBin; this-&gt;dealWithFcs(); this-&gt;dealWithMac();&#125;void Frame::input()&#123; getline(cin, this-&gt;data); cout &lt;&lt; &quot;-----------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::output()&#123; cout &lt;&lt; &quot;MAC帧（二进制）为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;mac &lt;&lt; endl; cout &lt;&lt; &quot;目的地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Destination &lt;&lt; endl; cout &lt;&lt; &quot;原地址为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;Source &lt;&lt; endl; cout &lt;&lt; &quot;长度为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macByteLenth &lt;&lt; endl; cout &lt;&lt; &quot;数据为:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;dataBin &lt;&lt; endl; cout &lt;&lt; &quot;FCS为：&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcs &lt;&lt; endl; cout &lt;&lt; &quot;MAC帧（十六进制）:&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;macHex &lt;&lt; endl; cout &lt;&lt; &quot;FCS(16进制):&quot; &lt;&lt; endl; cout &lt;&lt; this-&gt;fcsHex &lt;&lt; endl; cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; endl;&#125;void Frame::dealWithDestinationAddress()&#123; this-&gt;destinationBin = this-&gt;hexToBinary(this-&gt;Destination); this-&gt;mac += this-&gt;destinationBin;&#125;void Frame::dealWithSourceAddress()&#123; this-&gt;SourceBin = this-&gt;hexToBinary(this-&gt;Source); this-&gt;mac += this-&gt;SourceBin;&#125;void Frame::dealWithData()&#123; int dataByteLength = 0; this-&gt;dataBin = this-&gt;dataToBinaryString(data); dataByteLength = this-&gt;dataBin.size() / 8; if (dataByteLength &lt; 46) &#123; this-&gt;dataBin = this-&gt;fillZero(this-&gt;dataBin, 46 * 8, false); dataByteLength = 46; &#125; else if (dataByteLength &gt; 1500) &#123; cout &lt;&lt; &quot;输入超出范围&quot; &lt;&lt; endl; exit(0); &#125; this-&gt;macByteLenth += dataByteLength;&#125;void Frame::dealWithLengthField()&#123; this-&gt;lengthField = toBinaryString(this-&gt;macByteLenth); this-&gt;lengthField = this-&gt;fillZero(this-&gt;lengthField, 16, true);&#125;string Frame::toBinaryString(int num)&#123; string result = &quot;&quot;; while (num / 2 != 0) &#123; result.insert(0, to_string(num % 2)); num /= 2; &#125; result.insert(0, to_string(num)); return result;&#125;void Frame::dealWithFcs()&#123; string dividend = this-&gt;fillZero(this-&gt;mac, this-&gt;mac.length() + 32, false); this-&gt;fcs = this-&gt;solveFcs(dividend, this-&gt;Divisor); this-&gt;fcsHex = this-&gt;binaryToHex(this-&gt;fcs); this-&gt;mac += this-&gt;fcs;&#125;void Frame::dealWithMac()&#123; this-&gt;macHex = this-&gt;binaryToHex(this-&gt;mac);&#125;string Frame::solveFcs(string dividend, string divisor)&#123; string fcs = &quot;&quot;; int head = 0; int tail = head + divisor.length() - 1; int i; while (tail &lt; dividend.length()) &#123; if (&#x27;1&#x27; == dividend[head]) &#123; for (i = head; i &lt;= tail; i++) &#123; if (dividend[i] == divisor[i - head]) &#123; dividend[i] = &#x27;0&#x27;; &#125; else &#123; dividend[i] = &#x27;1&#x27;; &#125; &#125; &#125; head++; tail++; &#125; for (i = head; i &lt; dividend.length(); i++) &#123; fcs += dividend[i]; &#125; return fcs;&#125;string Frame::dataToBinaryString(string data)&#123; string result; string oneBit; for (int i = 0; i &lt; data.length(); i++) &#123; oneBit = toBinaryString(data[i]); oneBit = this-&gt;fillZero(oneBit, 8, true); result += oneBit; &#125; return result;&#125;string Frame::fillZero(string data, int finalBitLength, bool way)&#123; string result = &quot;&quot;; for (int i = data.length(); i &lt; finalBitLength; i++) &#123; result += &#x27;0&#x27;; &#125; if (way == true) &#123; result += data; &#125; else &#123; result = data + result; &#125; return result;&#125;string Frame::hexToBinary(string hex)&#123; string Binary = &quot;&quot;; int hexBitLength = hex.length(); for (int i = 0; i &lt; hexBitLength; i++) &#123; if (hex[i] &gt;= &#x27;0&#x27; &amp;&amp; hex[i] &lt;= &#x27;9&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;0&#x27;]; &#125; else if (hex[i] &gt;= &#x27;a&#x27; &amp;&amp; hex[i] &lt;= &#x27;z&#x27;) &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;a&#x27; + 10]; &#125; else &#123; Binary += this-&gt;FOUR_BIT_BIN[hex[i] - &#x27;A&#x27; + 10]; &#125; &#125; return Binary;&#125;string Frame::binaryToHex(string binary)&#123; string binToHex = &quot;&quot;; string tmp = &quot;&quot;; for (size_t j = 0; j &lt; binary.size(); j += 4) &#123; tmp = binary.substr(j, 4); if (!tmp.compare(&quot;0000&quot;)) binToHex += &quot;0&quot;; else if (!tmp.compare(&quot;0001&quot;)) binToHex += &quot;1&quot;; else if (!tmp.compare(&quot;0010&quot;)) binToHex += &quot;2&quot;; else if (!tmp.compare(&quot;0011&quot;)) binToHex += &quot;3&quot;; else if (!tmp.compare(&quot;0100&quot;)) binToHex += &quot;4&quot;; else if (!tmp.compare(&quot;0101&quot;)) binToHex += &quot;5&quot;; else if (!tmp.compare(&quot;0110&quot;)) binToHex += &quot;6&quot;; else if (!tmp.compare(&quot;0111&quot;)) binToHex += &quot;7&quot;; else if (!tmp.compare(&quot;1000&quot;)) binToHex += &quot;8&quot;; else if (!tmp.compare(&quot;1001&quot;)) binToHex += &quot;9&quot;; else if (!tmp.compare(&quot;1010&quot;)) binToHex += &quot;A&quot;; else if (!tmp.compare(&quot;1011&quot;)) binToHex += &quot;B&quot;; else if (!tmp.compare(&quot;1100&quot;)) binToHex += &quot;C&quot;; else if (!tmp.compare(&quot;1101&quot;)) binToHex += &quot;D&quot;; else if (!tmp.compare(&quot;1110&quot;)) binToHex += &quot;E&quot;; else if (!tmp.compare(&quot;1111&quot;)) binToHex += &quot;F&quot;; else continue; &#125; return binToHex;&#125;//稍显丑陋。。。int main()&#123; Frame frame; frame.begin(); frame.output();&#125; 实现截图","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"香农公式术语","slug":"计算机世界/香农公式术语","date":"2021-10-27T08:56:00.203Z","updated":"2021-10-27T09:01:09.919Z","comments":true,"path":"2021/10/27/计算机世界/香农公式术语/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/","excerpt":"","text":"波特率波特率（也称信息传送速率、码元速率、符号速率、传码率），其定义为每秒钟传送码元的数目，码元速率的单位为“波特”，常用符号“Baud”表示，简写为“B”。 一个数字脉冲就是一个码元，我们用码元速率表示单位时间内信号波形的变换次数，即单位时间内通过信道传输的码元个数。若信号码元宽度为T秒，则码元速率B为：$$B = 1/T(Baud)$$ 比特率比特率也称数据传输速率，它的定义是单位时间内可以传输的比特数，单位为bps。比特率的计算公式为：$$\\mbox{比特率}=\\mbox{波特率}*\\mbox{每码元含有的bit数}$$ 怎么理解比特率和波特率之间的关系呢？我们可以假设一个信号只有两个电平状态，那么这个时候可以把低电平理解为“0”，高电平理解为“1”，这样每秒钟电平变化的次数也就是传输的0，1个数了，即比特率 = 波特率。但是有些信号可能不止两个电平，比如一个四电平的信号状态，那么每个电平就可以被理解成“00”，“01”，“10”，“11”，这样每次电平变化就能传输两位的数据了，即比特率 = 2 × 波特率。 带宽和容量带宽：一般信道都有一个最高的信号频率（频率是指每秒钟的周期数，而每个周期都会有几次电平变化）和最低的信号频率，只有在这两个频率之间的信号才能通过这个信道，这两个频率的差值就叫做这个信道的带宽，单位是Hz。 信道的容量：数据在信道中传输会有他们的速度——比特率，这里面最高的比特率就叫做这个信道的容量，单位是bps。 口语中也会把信道容量叫做“带宽”的，比如“带宽10M的网络”，“网络带宽是10M”等等。所以这两个概念也很容易混淆：我们平常所说的“带宽”不是带宽，而是信道容量，这一点心里要清楚.","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"计算机网络","slug":"计算机世界/WireLine","date":"2021-10-27T01:38:37.020Z","updated":"2021-11-02T09:51:29.730Z","comments":true,"path":"2021/10/27/计算机世界/WireLine/","link":"","permalink":"http://example.com/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/WireLine/","excerpt":"","text":"物理层物理层基本概念物理层：解决怎样在连接各种计算机的传输媒体上传输数据比特流，而不指定具体的媒体。 物理层的任务：机械特性：指明接口所用接线器的形状和尺寸，引脚数目和排列固定和锁定装置等。电器特性：指明接口电缆中各条线上出现的电压范围。功能特性：指明某条线上出现某一电平的电压的意义。过程特性：指明对于不同功能的各种可能事件出现的顺序。转换任务：将并行数据转换为串行数据。 数据通信的基本知识数据通信系统： 源系统：分为源点，发送器（调制器） 传输系统：传输网络 目的系统：接收器（解调器），终点 常用术语：消息：例如语音，文字，图片等。数据：运送消息的载体。信号：数据的电气或电磁表现。模拟信号：连续的信号。数字信号：离散的信号。码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。 关于信道的基本概念：定义：用来表示向某一个方向传送信息的媒体。交互方式：单工，半双工，全双工。基带信号：来自信源的信号称为基带信号，一般包含较多的低频成分，甚至有直流成分，许多信道不能传输这种低频分量和直流分量，所以必须对基带信号进行调制。 调制： 基带调制（编码）：对基带信号的波形进行变换，使它能够与信道特性相适应，变换后的信号仍然是基带信号。 带通调制：通过使用载波进行调制，将基带信号搬移到较高频段，并转换为模拟信号。转换完后的信号称为带通信号。 常用的编码方式： 不归零制：正电平代表1，负电平代表0.（没有自同步能力，不能从信号波形本身提取出信号的时钟频率）。 归零制：正脉冲代表1，负脉冲代表0。 曼彻斯特编码：为中心周期向下跳变代表1，向下跳变代表0。（也可以反过来） 差分曼彻斯特编码：在每一位中心始终都有跳变，位开始边界有跳变代表0，没有跳变代表1。 基本的带通调制方法： 调幅（AM）：即载波的振幅随基带数字信号变化。 调频（FM）：即载波的频率随基带的数字信号变化。 调相（PM）：即载波的初始相位随基带的数字型号变化。 为提高信息的传输速率，通常使用正交振幅调制（一个码元代表多个bit）。 信道的极限容量传输质量：码元的传输速率越高，或传输的距离越远，或噪声干扰越大，则传输媒体质量越大，失真越严重。 码间干扰：在接受端收到的信号波形失去了码元之间清晰的界限。 奈氏准则在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间干扰，使接受端识别数据称为不可能。 信噪比定义：信号的平均功率和噪声的平均功率之比，常记为$ S/N $,并用分贝（dB）作为度量单位。即：$$\\mbox{信噪比}(dB) = 10 \\log_{10}(S/N)(dB)$$ 香农公式$$C = W \\log_2(1+S/N)(bit/s)$$其中 W 为信道带宽，单位为（Hz），C为信道的极限传输速率，香农公式表明，信道的带宽或者信道的信噪比越大，信息的极限传输速率就越高。 术语https://please.sendmeto.icu/2021/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/%E9%A6%99%E5%86%9C%E5%85%AC%E5%BC%8F%E6%9C%AF%E8%AF%AD/ 信道复用技术频分复用：相同时间不同频率时分复用：不同时间相同频率，将一个复用帧分为多个时隙，每个时隙分配给一个用户统计时分复用：动态分配的时分复用波分复用：光的频分复用，每隔120km添加一个放大器，可保证光信号不会衰减到不能被识别码分复用：各用户使用经过特殊挑选的不同码型，进行通信。 码分多址特点：很强的抗干扰能力，频谱类似于白噪声，不易被敌人发现。现在多使用在无线网中。复用方式：每一个比特时间再划分为m个短的间隔，称为码片，通常m的值为64或者128，使用CDMA的每个站被指派一个唯一的m bit的码片序列，一个站如果要发送1，则发送它自身的码片序列，如果要发送0，则发送自身码片序列的反码。惯例将码片中的0写作-1，将1写作+1.不同的码片序列必须相互正交。因为不同的码片序列之间是相互正交的，设S站的码片序列为S，T站的码片序列为T。$$S * T = 1/m \\Sigma S_i T_i = 0$$$$S * S = 1/m \\Sigma S_i^2 = 1$$因此如果S发射1，则接受方用$S * S$ 会得到1，如果S发射0，则接受方用$S * S$会得到-1.用此方法，如果接受方有S的码片序列，那么就可以收到A发射的消息。 数据链路层主要内容： 点对点信道和广播信道的特点，以及这两种信道所使用的协议的特点(PPP 协议一节 CSMA/CD 协议)。 数据链路层的三个基本问题：封装成帧，透明传输和差错检验。 以太网MAC层的硬件地址 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。 使用点对点信道的数据链路层数据链路和链路的区别： 链路：是从一个结点到相邻结点的一段物理线路（有线或者无线），而中间没有任何其他的交换结点。 数据链路：把视线协议的硬件和软件加到链路上，就构成了数据链路。 数据链路层的协议数据单元：帧网络层的协议数据单元：IP数据报 点对点信道的数据链路层在进行通行的时候主要步骤： 结点A的数据链路层把网络层传下来的数据封装成帧 结点A把帧传输给结点B的数据链路层 结点B检验帧无差错，接受帧，否则丢弃帧 封装成帧在一段数据的前后分别添加首部和尾部，构成一个帧。首部SOH(Start Of Header),尾部EOT(End Of Transmission)是两种控制字符，并不是三个字符，在键盘中都不可输入。用于帧定界。 透明传输保证数据的完整性不因为数据中含有和定界符而在传输中丢失。 具体做法：发送端的数据链路层在数据中出现控制字符”SOH”,”EOT”,”ESC”的前面添加一个转移字符”ESC”，而在接受端的数据链路层删除这个转义字符，这种方法称为字符填充或者字节填充（byte stuffing）。 差错检验误码率：传输错误bit数占传输bit总数的比率CRC(Cyclic Redundancy Check)循环冗余检验技术被广泛用于数据链路层差错检验。检验方法： $$( M * 2^n ) / P= Q……R$$ 发送$M * 2^n + R$,接收方把每一帧都除以P，若余数为零则代表没有出现差错，否则代表出现差错，该式子中所有的除法均代表模二除法。其中P是n+1位二进制数，R是n位二进制数，被称作FCS(Frame Check Sequence)(冗余码，帧检验序列)。 CRC只能检测出bit差错，所以并不能进行可靠传输，如果想进行可靠传输，还需要增加帧编号，确认和重传机制，防止帧丢失，帧重复，帧失序。 详见https://please.sendmeto.icu/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/mac%E5%B0%81%E8%A3%85/ 拓展以太网在数据链路层拓展以太网早期使用网桥，现在使用以太网交换机。==网桥==：根据mac帧的目的地址和地址表（交换表）对收到的帧进行转发和过滤。 ==以太网交换机==：实质是多接口网桥，内部地址表是通过自学习算法逐渐建立起来的。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Captt-g"},{"title":"LeetCode刷题记录","slug":"计算机世界/LeetCode","date":"2021-10-26T07:02:03.751Z","updated":"2021-10-26T13:08:54.228Z","comments":true,"path":"2021/10/26/计算机世界/LeetCode/","link":"","permalink":"http://example.com/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/LeetCode/","excerpt":"","text":"287. Find the Duplicate Number题目大意：给n+1个int值,1 &lt;= value &lt;= n,找出它们中的重复数字,时间复杂度为O(n^2),空间复杂度为O(1). 解决方法：使用二分法,记数组最大值，中值，最小值分别为max，mid，low，如果小于mid的数超过mid个，则重复的数字小于mid，否则大于mid。重复此过程。 123456789101112131415161718192021222324252627int findDuplicate(int *nums, int numsSize)&#123; int low = 0; int high = numsSize - 1; while (low &lt; high) &#123; int mid = (low + high) / 2; int count = 0; for (int i = 0; i &lt; numsSize; i++) &#123; if (nums[i] &lt;= mid) &#123; count++; &#125; &#125; if (count &gt; mid) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; return low;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"经典诗词","slug":"诗词世界/诗词世界","date":"2021-10-26T06:20:06.541Z","updated":"2021-11-02T15:09:29.599Z","comments":true,"path":"2021/10/26/诗词世界/诗词世界/","link":"","permalink":"http://example.com/2021/10/26/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/%E8%AF%97%E8%AF%8D%E4%B8%96%E7%95%8C/","excerpt":"","text":"临安春雨初霁（陆游)世味年来薄似纱，谁令骑马客京华。 小楼一夜听春雨，深巷明朝卖杏花。 矮纸斜行闲作草，晴窗细乳戏分茶。 素衣莫起风尘叹，犹及清明可到家。 临江仙·滚滚长江东逝水（杨慎）滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。 白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。","categories":[],"tags":[{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"}],"author":"Captt-g"},{"title":"JavaScript 基础语法学习笔记","slug":"计算机世界/JavaScript基础知识","date":"2021-10-25T13:15:22.546Z","updated":"2021-11-08T03:51:41.380Z","comments":true,"path":"2021/10/25/计算机世界/JavaScript基础知识/","link":"","permalink":"http://example.com/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"严格模式1&#x27;use strict&#x27;; 用break/continue和标签跳出多重循环只有在循环内部使用才可以调到标签所在位置。 123456outer: for(...)&#123; for(...)&#123; if(...) break outer;//从这里直接运行到alert &#125;&#125;alert(&#x27;Done!&#x27;) 函数箭头函数 12let func = ( arg1, arg2, ...argN)=&gt; expressionlet func = ( arg1, arg2, ...argN)=&gt; &#123; body &#125; 使用参数对expression求值并返回结果。等同于 123let func = function( arg1, arg2,... argN)&#123; return expression;&#125;; 例子 1let sum = ( a, b) =&gt; a + b; 对象js中的对象是一组键值对数据。 12345678910//创建空的对象let user=new Object();let user=&#123; name:&quot;John&quot;, age:30, &quot;like birds&quot;:true,&#125;;//删除属性delete user.age;alert(user[&quot;like birds&quot;]); 属性的命名没有限制，可以是任何字符串或者symbol，若命名数字也会被转换为字符串。 当被访问的属性不存在的时候会返回undefined。 计算属性当创建一个对象的时候，可以在对象字面量中使用方括号。 12345678910let fruit = prompt(&quot;Which fruit to buy?&quot;,&quot;apple&quot;);let bag=&#123; [fruit]:5,&#125;;alert(bag[fruit])//在方括号中使用更复杂的表达式let bag = &#123; [fruit+&#x27;Computers&#x27;]:5 ,&#125; 对象的克隆和引用对象名是对对象的引用，指向的是地址想要复制对象，可以使用 1Object.assign(dest, [src1, src2, src3...]) 该式子会把源对象的属性全部复制进dest 箭头函数没有自己的this箭头函数有些特别：它们没有自己的 this。如果我们在这样的函数中引用 this，this 值取决于外部“正常的”函数。 123456789let user = &#123; firstName: &quot;Ilya&quot;, sayHi() &#123; let arrow = () =&gt; alert(this.firstName); arrow(); &#125;&#125;;user.sayHi(); // Ilya 这是箭头函数的一个特性，当我们并不想要一个独立的 this，反而想从外部上下文中获取时，它很有用。 构造函数构造函数的两个约定： 命名以大写字母开头。 只能由new操作符来执行12345678function User(name)&#123; this.name=name; this.isAdmin=false;&#125;let user = new User(&quot;Jack&quot;);alert(user.name);alert(user.isAdmin); 从技术上讲，任何函数（除了箭头函数，它没有自己的 this）都可以用作构造器。即可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。 常用内置对象：Object，Math.Data,String.Number,Array,Boolean,Function.由浏览器提供的对象：BOM，DOM。 基础包装类型String字符串的所有方法都不会改变原字符串 indexOf()/lastIndexOf():获取字符串中指定内容的索引，如果没有找到，返回-1. charAt(index),获取指定索引上的字符 charCodeAt(index),返回字符串指定位置的unicode编码，在实际应用中可以通过这个方法判断永无按下哪个按键。 silce(开始索引,结束索引),截取字符串，按照索引位置截取，包左不包右。 substr(开始索引，截取长度) split(分割符)，通过指定分割符，将一个字符串拆分成一个数组，不会改变原字符。 trim()，取出字符串前后的空白 anchor(),创建a连接 link(url),连接到url中Number和Math Number.isInteger(),判断是否为整数 toFixed(num)小数点后面保留num位 Math.ceil()，向上取整 Math.floor(),向下取整 Math.round(),四舍五入取整 Math.random(),生成0，1之间的随机数url编码和解码1234var url = &quot;https://www.baidu.com&quot;;var str = encodeURIComponent();console.log(str);console.log(decodeURIComponent(str)); Date用于处理日期和时间，需要进行实例化后使用 不传递参数，获取当前系统时间对象，date=Date() 传递字符串参数、数字参数，时间戳 Array Array.from(arrayLike),将伪数组转换为真数组，例如字符串 Array.of(),创建数组 push()，pop() unshift(),在数组前面插入一个或多个元素 shift(),删除数组中的第一个元素，返回结果为被删除的元素 splice(),删除指定位置的元素，返回删除的元素组成的新数组。 slice(),提取指定位置的元素组成新数组","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}],"author":"Captt-g"},{"title":"排序算法","slug":"计算机世界/Sort","date":"2021-10-24T13:10:15.993Z","updated":"2021-10-26T07:02:47.368Z","comments":true,"path":"2021/10/24/计算机世界/Sort/","link":"","permalink":"http://example.com/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%96%E7%95%8C/Sort/","excerpt":"","text":"插入排序 概念：0~p-1位置的数是排好序的，将第p位置上的数插入进排好序的数列里，形成新的排好序的数列。 12345678910void InsertSort(ElementType a[],int n)&#123; for(int i=1;i&lt;n;i++)&#123; ElementType tmp=a[i]; int j; for(j=i;j&gt;0&amp;&amp;a[j-1]&gt;tmp;j--)&#123; a[j]=a[j-1]; &#125; a[j]=tmp; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Captt-g"},{"title":"当一个人","slug":"杂项/beaman","date":"2021-10-22T08:41:13.470Z","updated":"2021-10-24T15:05:35.571Z","comments":true,"path":"2021/10/22/杂项/beaman/","link":"","permalink":"http://example.com/2021/10/22/%E6%9D%82%E9%A1%B9/beaman/","excerpt":"","text":"当一个人 从明天开始我要当一个不再摆烂的人，早睡早起，每天吃早饭，认真看书学习，只在周末打游戏。","categories":[],"tags":[],"author":"Captt-g"}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/categories/JAVA/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"django","slug":"django","permalink":"http://example.com/tags/django/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"诗词","slug":"诗词","permalink":"http://example.com/tags/%E8%AF%97%E8%AF%8D/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]}